// Code generated from /private/var/tmp/_bazel_graham/081e5e0bb1448a80684d6ec6cd93bc45/sandbox/darwin-sandbox/99/execroot/__main__/pkg/xpa/grammar/XPath31.g4 by ANTLR 4.8. DO NOT EDIT.

package XPath31 // XPath31
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa


var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 107, 904, 
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7, 
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13, 
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9, 
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23, 
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4, 
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34, 
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9, 
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44, 
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4, 
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55, 
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9, 
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65, 
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4, 
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76, 
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9, 
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86, 
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4, 
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97, 
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102, 
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106, 
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111, 
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 3, 2, 3, 2, 3, 
	2, 3, 3, 3, 3, 3, 3, 7, 3, 235, 10, 3, 12, 3, 14, 3, 238, 11, 3, 3, 4, 
	3, 4, 3, 4, 5, 4, 243, 10, 4, 3, 5, 3, 5, 3, 6, 3, 6, 5, 6, 249, 10, 6, 
	3, 6, 3, 6, 3, 7, 3, 7, 3, 7, 7, 7, 256, 10, 7, 12, 7, 14, 7, 259, 11, 
	7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8, 266, 10, 8, 3, 9, 3, 9, 3, 9, 3, 
	9, 3, 10, 3, 10, 3, 10, 3, 10, 7, 10, 276, 10, 10, 12, 10, 14, 10, 279, 
	11, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 
	3, 13, 3, 13, 3, 13, 3, 13, 7, 13, 294, 10, 13, 12, 13, 14, 13, 297, 11, 
	13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 7, 15, 315, 10, 15, 12, 15, 14, 
	15, 318, 11, 15, 3, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 
	3, 16, 3, 16, 3, 16, 3, 16, 3, 17, 3, 17, 3, 17, 7, 17, 335, 10, 17, 12, 
	17, 14, 17, 338, 11, 17, 3, 18, 3, 18, 3, 18, 7, 18, 343, 10, 18, 12, 18, 
	14, 18, 346, 11, 18, 3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 352, 10, 19, 3, 
	19, 3, 19, 5, 19, 356, 10, 19, 3, 20, 3, 20, 3, 20, 7, 20, 361, 10, 20, 
	12, 20, 14, 20, 364, 11, 20, 3, 21, 3, 21, 3, 21, 5, 21, 369, 10, 21, 3, 
	22, 3, 22, 3, 22, 7, 22, 374, 10, 22, 12, 22, 14, 22, 377, 11, 22, 3, 23, 
	3, 23, 3, 23, 7, 23, 382, 10, 23, 12, 23, 14, 23, 385, 11, 23, 3, 24, 3, 
	24, 3, 24, 7, 24, 390, 10, 24, 12, 24, 14, 24, 393, 11, 24, 3, 25, 3, 25, 
	3, 25, 7, 25, 398, 10, 25, 12, 25, 14, 25, 401, 11, 25, 3, 26, 3, 26, 3, 
	26, 3, 26, 5, 26, 407, 10, 26, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 413, 
	10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 419, 10, 28, 3, 29, 3, 29, 3, 
	29, 3, 29, 5, 29, 425, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 
	432, 10, 30, 12, 30, 14, 30, 435, 11, 30, 3, 31, 7, 31, 438, 10, 31, 12, 
	31, 14, 31, 441, 11, 31, 3, 31, 3, 31, 3, 32, 3, 32, 3, 33, 3, 33, 3, 34, 
	3, 34, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 7, 36, 456, 10, 36, 12, 36, 14, 
	36, 459, 11, 36, 3, 37, 3, 37, 5, 37, 463, 10, 37, 3, 37, 3, 37, 3, 37, 
	5, 37, 468, 10, 37, 3, 38, 3, 38, 3, 38, 7, 38, 473, 10, 38, 12, 38, 14, 
	38, 476, 11, 38, 3, 39, 3, 39, 5, 39, 480, 10, 39, 3, 40, 3, 40, 5, 40, 
	484, 10, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 5, 41, 492, 10, 
	41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 
	3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 510, 10, 42, 3, 43, 5, 
	43, 513, 10, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 521, 
	10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 
	3, 45, 5, 45, 533, 10, 45, 3, 46, 3, 46, 3, 47, 3, 47, 5, 47, 539, 10, 
	47, 3, 48, 3, 48, 5, 48, 543, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49, 3, 49, 
	3, 49, 3, 49, 5, 49, 552, 10, 49, 3, 50, 3, 50, 3, 50, 3, 50, 7, 50, 558, 
	10, 50, 12, 50, 14, 50, 561, 11, 50, 3, 51, 3, 51, 3, 51, 3, 51, 7, 51, 
	567, 10, 51, 12, 51, 14, 51, 570, 11, 51, 5, 51, 572, 10, 51, 3, 51, 3, 
	51, 3, 52, 7, 52, 577, 10, 52, 12, 52, 14, 52, 580, 11, 52, 3, 53, 3, 53, 
	3, 53, 3, 53, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 5, 55, 593, 
	10, 55, 3, 56, 3, 56, 3, 56, 5, 56, 598, 10, 56, 3, 57, 3, 57, 3, 57, 3, 
	57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57, 609, 10, 57, 3, 58, 3, 58, 
	5, 58, 613, 10, 58, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 61, 3, 61, 3, 
	62, 3, 62, 5, 62, 624, 10, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 64, 3, 64, 
	3, 64, 3, 64, 3, 65, 3, 65, 5, 65, 636, 10, 65, 3, 66, 3, 66, 3, 67, 3, 
	67, 5, 67, 642, 10, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 
	5, 69, 651, 10, 69, 3, 69, 3, 69, 3, 69, 5, 69, 656, 10, 69, 3, 69, 3, 
	69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 7, 70, 665, 10, 70, 12, 70, 14, 
	70, 668, 11, 70, 5, 70, 670, 10, 70, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 
	3, 71, 3, 72, 3, 72, 3, 73, 3, 73, 3, 74, 3, 74, 5, 74, 684, 10, 74, 3, 
	75, 3, 75, 3, 75, 3, 75, 7, 75, 690, 10, 75, 12, 75, 14, 75, 693, 11, 75, 
	5, 75, 695, 10, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77, 3, 
	77, 3, 78, 3, 78, 5, 78, 707, 10, 78, 3, 79, 3, 79, 3, 79, 3, 80, 3, 80, 
	3, 80, 3, 80, 3, 80, 5, 80, 717, 10, 80, 5, 80, 719, 10, 80, 3, 81, 3, 
	81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 
	732, 10, 82, 3, 83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 
	84, 3, 84, 3, 84, 3, 84, 5, 84, 746, 10, 84, 3, 85, 3, 85, 3, 85, 3, 85, 
	3, 86, 3, 86, 3, 86, 3, 86, 5, 86, 756, 10, 86, 3, 86, 3, 86, 3, 87, 3, 
	87, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 3, 88, 3, 89, 3, 89, 3, 89, 3, 89, 
	3, 90, 3, 90, 3, 90, 5, 90, 775, 10, 90, 3, 90, 3, 90, 3, 91, 3, 91, 3, 
	91, 3, 91, 3, 91, 5, 91, 784, 10, 91, 5, 91, 786, 10, 91, 3, 91, 3, 91, 
	3, 92, 3, 92, 5, 92, 792, 10, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 
	94, 3, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 3, 95, 5, 95, 807, 10, 95, 
	5, 95, 809, 10, 95, 5, 95, 811, 10, 95, 3, 95, 3, 95, 3, 96, 3, 96, 5, 
	96, 817, 10, 96, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 99, 
	3, 99, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 3, 103, 3, 103, 
	5, 103, 836, 10, 103, 3, 104, 3, 104, 3, 104, 3, 104, 3, 104, 3, 105, 3, 
	105, 3, 105, 3, 105, 3, 105, 7, 105, 848, 10, 105, 12, 105, 14, 105, 851, 
	11, 105, 5, 105, 853, 10, 105, 3, 105, 3, 105, 3, 105, 3, 105, 3, 106, 
	3, 106, 5, 106, 861, 10, 106, 3, 107, 3, 107, 3, 107, 3, 107, 3, 107, 3, 
	108, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3, 109, 3, 109, 5, 
	109, 877, 10, 109, 3, 110, 3, 110, 3, 110, 3, 110, 3, 110, 3, 111, 3, 111, 
	3, 111, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 113, 3, 113, 
	3, 114, 3, 114, 3, 114, 6, 114, 898, 10, 114, 13, 114, 14, 114, 899, 3, 
	114, 3, 114, 3, 114, 2, 2, 115, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 
	156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 
	186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 
	216, 218, 220, 222, 224, 226, 2, 15, 4, 2, 56, 56, 91, 91, 4, 2, 24, 24, 
	30, 30, 6, 2, 37, 37, 50, 50, 64, 64, 75, 75, 4, 2, 29, 29, 96, 96, 4, 
	2, 57, 57, 68, 68, 6, 2, 17, 18, 20, 21, 23, 23, 25, 25, 7, 2, 55, 55, 
	62, 63, 71, 71, 73, 73, 78, 78, 5, 2, 19, 19, 22, 22, 69, 69, 3, 2, 35, 
	36, 3, 2, 97, 99, 5, 2, 30, 30, 33, 33, 37, 37, 4, 2, 100, 100, 105, 105, 
	6, 2, 38, 93, 95, 96, 101, 101, 104, 104, 2, 908, 2, 228, 3, 2, 2, 2, 4, 
	231, 3, 2, 2, 2, 6, 239, 3, 2, 2, 2, 8, 244, 3, 2, 2, 2, 10, 246, 3, 2, 
	2, 2, 12, 252, 3, 2, 2, 2, 14, 265, 3, 2, 2, 2, 16, 267, 3, 2, 2, 2, 18, 
	271, 3, 2, 2, 2, 20, 280, 3, 2, 2, 2, 22, 285, 3, 2, 2, 2, 24, 289, 3, 
	2, 2, 2, 26, 298, 3, 2, 2, 2, 28, 303, 3, 2, 2, 2, 30, 322, 3, 2, 2, 2, 
	32, 331, 3, 2, 2, 2, 34, 339, 3, 2, 2, 2, 36, 347, 3, 2, 2, 2, 38, 357, 
	3, 2, 2, 2, 40, 365, 3, 2, 2, 2, 42, 370, 3, 2, 2, 2, 44, 378, 3, 2, 2, 
	2, 46, 386, 3, 2, 2, 2, 48, 394, 3, 2, 2, 2, 50, 402, 3, 2, 2, 2, 52, 408, 
	3, 2, 2, 2, 54, 414, 3, 2, 2, 2, 56, 420, 3, 2, 2, 2, 58, 426, 3, 2, 2, 
	2, 60, 439, 3, 2, 2, 2, 62, 444, 3, 2, 2, 2, 64, 446, 3, 2, 2, 2, 66, 448, 
	3, 2, 2, 2, 68, 450, 3, 2, 2, 2, 70, 452, 3, 2, 2, 2, 72, 467, 3, 2, 2, 
	2, 74, 469, 3, 2, 2, 2, 76, 479, 3, 2, 2, 2, 78, 483, 3, 2, 2, 2, 80, 491, 
	3, 2, 2, 2, 82, 509, 3, 2, 2, 2, 84, 512, 3, 2, 2, 2, 86, 520, 3, 2, 2, 
	2, 88, 532, 3, 2, 2, 2, 90, 534, 3, 2, 2, 2, 92, 538, 3, 2, 2, 2, 94, 542, 
	3, 2, 2, 2, 96, 551, 3, 2, 2, 2, 98, 553, 3, 2, 2, 2, 100, 562, 3, 2, 2, 
	2, 102, 578, 3, 2, 2, 2, 104, 581, 3, 2, 2, 2, 106, 585, 3, 2, 2, 2, 108, 
	592, 3, 2, 2, 2, 110, 597, 3, 2, 2, 2, 112, 608, 3, 2, 2, 2, 114, 612, 
	3, 2, 2, 2, 116, 614, 3, 2, 2, 2, 118, 616, 3, 2, 2, 2, 120, 619, 3, 2, 
	2, 2, 122, 621, 3, 2, 2, 2, 124, 627, 3, 2, 2, 2, 126, 629, 3, 2, 2, 2, 
	128, 635, 3, 2, 2, 2, 130, 637, 3, 2, 2, 2, 132, 641, 3, 2, 2, 2, 134, 
	643, 3, 2, 2, 2, 136, 647, 3, 2, 2, 2, 138, 659, 3, 2, 2, 2, 140, 673, 
	3, 2, 2, 2, 142, 677, 3, 2, 2, 2, 144, 679, 3, 2, 2, 2, 146, 683, 3, 2, 
	2, 2, 148, 685, 3, 2, 2, 2, 150, 698, 3, 2, 2, 2, 152, 701, 3, 2, 2, 2, 
	154, 704, 3, 2, 2, 2, 156, 708, 3, 2, 2, 2, 158, 718, 3, 2, 2, 2, 160, 
	720, 3, 2, 2, 2, 162, 731, 3, 2, 2, 2, 164, 733, 3, 2, 2, 2, 166, 745, 
	3, 2, 2, 2, 168, 747, 3, 2, 2, 2, 170, 751, 3, 2, 2, 2, 172, 759, 3, 2, 
	2, 2, 174, 763, 3, 2, 2, 2, 176, 767, 3, 2, 2, 2, 178, 771, 3, 2, 2, 2, 
	180, 778, 3, 2, 2, 2, 182, 791, 3, 2, 2, 2, 184, 793, 3, 2, 2, 2, 186, 
	798, 3, 2, 2, 2, 188, 800, 3, 2, 2, 2, 190, 816, 3, 2, 2, 2, 192, 818, 
	3, 2, 2, 2, 194, 823, 3, 2, 2, 2, 196, 825, 3, 2, 2, 2, 198, 827, 3, 2, 
	2, 2, 200, 829, 3, 2, 2, 2, 202, 831, 3, 2, 2, 2, 204, 835, 3, 2, 2, 2, 
	206, 837, 3, 2, 2, 2, 208, 842, 3, 2, 2, 2, 210, 860, 3, 2, 2, 2, 212, 
	862, 3, 2, 2, 2, 214, 867, 3, 2, 2, 2, 216, 876, 3, 2, 2, 2, 218, 878, 
	3, 2, 2, 2, 220, 883, 3, 2, 2, 2, 222, 888, 3, 2, 2, 2, 224, 892, 3, 2, 
	2, 2, 226, 897, 3, 2, 2, 2, 228, 229, 5, 12, 7, 2, 229, 230, 7, 2, 2, 3, 
	230, 3, 3, 2, 2, 2, 231, 236, 5, 6, 4, 2, 232, 233, 7, 10, 2, 2, 233, 235, 
	5, 6, 4, 2, 234, 232, 3, 2, 2, 2, 235, 238, 3, 2, 2, 2, 236, 234, 3, 2, 
	2, 2, 236, 237, 3, 2, 2, 2, 237, 5, 3, 2, 2, 2, 238, 236, 3, 2, 2, 2, 239, 
	240, 7, 15, 2, 2, 240, 242, 5, 224, 113, 2, 241, 243, 5, 156, 79, 2, 242, 
	241, 3, 2, 2, 2, 242, 243, 3, 2, 2, 2, 243, 7, 3, 2, 2, 2, 244, 245, 5, 
	10, 6, 2, 245, 9, 3, 2, 2, 2, 246, 248, 7, 27, 2, 2, 247, 249, 5, 12, 7, 
	2, 248, 247, 3, 2, 2, 2, 248, 249, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250, 
	251, 7, 6, 2, 2, 251, 11, 3, 2, 2, 2, 252, 257, 5, 14, 8, 2, 253, 254, 
	7, 10, 2, 2, 254, 256, 5, 14, 8, 2, 255, 253, 3, 2, 2, 2, 256, 259, 3, 
	2, 2, 2, 257, 255, 3, 2, 2, 2, 257, 258, 3, 2, 2, 2, 258, 13, 3, 2, 2, 
	2, 259, 257, 3, 2, 2, 2, 260, 266, 5, 16, 9, 2, 261, 266, 5, 22, 12, 2, 
	262, 266, 5, 28, 15, 2, 263, 266, 5, 30, 16, 2, 264, 266, 5, 32, 17, 2, 
	265, 260, 3, 2, 2, 2, 265, 261, 3, 2, 2, 2, 265, 262, 3, 2, 2, 2, 265, 
	263, 3, 2, 2, 2, 265, 264, 3, 2, 2, 2, 266, 15, 3, 2, 2, 2, 267, 268, 5, 
	18, 10, 2, 268, 269, 7, 86, 2, 2, 269, 270, 5, 14, 8, 2, 270, 17, 3, 2, 
	2, 2, 271, 272, 7, 60, 2, 2, 272, 277, 5, 20, 11, 2, 273, 274, 7, 10, 2, 
	2, 274, 276, 5, 20, 11, 2, 275, 273, 3, 2, 2, 2, 276, 279, 3, 2, 2, 2, 
	277, 275, 3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 19, 3, 2, 2, 2, 279, 277, 
	3, 2, 2, 2, 280, 281, 7, 15, 2, 2, 281, 282, 5, 120, 61, 2, 282, 283, 7, 
	66, 2, 2, 283, 284, 5, 14, 8, 2, 284, 21, 3, 2, 2, 2, 285, 286, 5, 24, 
	13, 2, 286, 287, 7, 86, 2, 2, 287, 288, 5, 14, 8, 2, 288, 23, 3, 2, 2, 
	2, 289, 290, 7, 72, 2, 2, 290, 295, 5, 26, 14, 2, 291, 292, 7, 10, 2, 2, 
	292, 294, 5, 26, 14, 2, 293, 291, 3, 2, 2, 2, 294, 297, 3, 2, 2, 2, 295, 
	293, 3, 2, 2, 2, 295, 296, 3, 2, 2, 2, 296, 25, 3, 2, 2, 2, 297, 295, 3, 
	2, 2, 2, 298, 299, 7, 15, 2, 2, 299, 300, 5, 120, 61, 2, 300, 301, 7, 7, 
	2, 2, 301, 302, 5, 14, 8, 2, 302, 27, 3, 2, 2, 2, 303, 304, 9, 2, 2, 2, 
	304, 305, 7, 15, 2, 2, 305, 306, 5, 120, 61, 2, 306, 307, 7, 66, 2, 2, 
	307, 316, 5, 14, 8, 2, 308, 309, 7, 10, 2, 2, 309, 310, 7, 15, 2, 2, 310, 
	311, 5, 120, 61, 2, 311, 312, 7, 66, 2, 2, 312, 313, 5, 14, 8, 2, 313, 
	315, 3, 2, 2, 2, 314, 308, 3, 2, 2, 2, 315, 318, 3, 2, 2, 2, 316, 314, 
	3, 2, 2, 2, 316, 317, 3, 2, 2, 2, 317, 319, 3, 2, 2, 2, 318, 316, 3, 2, 
	2, 2, 319, 320, 7, 87, 2, 2, 320, 321, 5, 14, 8, 2, 321, 29, 3, 2, 2, 2, 
	322, 323, 7, 65, 2, 2, 323, 324, 7, 28, 2, 2, 324, 325, 5, 12, 7, 2, 325, 
	326, 7, 11, 2, 2, 326, 327, 7, 93, 2, 2, 327, 328, 5, 14, 8, 2, 328, 329, 
	7, 53, 2, 2, 329, 330, 5, 14, 8, 2, 330, 31, 3, 2, 2, 2, 331, 336, 5, 34, 
	18, 2, 332, 333, 7, 81, 2, 2, 333, 335, 5, 34, 18, 2, 334, 332, 3, 2, 2, 
	2, 335, 338, 3, 2, 2, 2, 336, 334, 3, 2, 2, 2, 336, 337, 3, 2, 2, 2, 337, 
	33, 3, 2, 2, 2, 338, 336, 3, 2, 2, 2, 339, 344, 5, 36, 19, 2, 340, 341, 
	7, 40, 2, 2, 341, 343, 5, 36, 19, 2, 342, 340, 3, 2, 2, 2, 343, 346, 3, 
	2, 2, 2, 344, 342, 3, 2, 2, 2, 344, 345, 3, 2, 2, 2, 345, 35, 3, 2, 2, 
	2, 346, 344, 3, 2, 2, 2, 347, 355, 5, 38, 20, 2, 348, 352, 5, 66, 34, 2, 
	349, 352, 5, 64, 33, 2, 350, 352, 5, 68, 35, 2, 351, 348, 3, 2, 2, 2, 351, 
	349, 3, 2, 2, 2, 351, 350, 3, 2, 2, 2, 352, 353, 3, 2, 2, 2, 353, 354, 
	5, 38, 20, 2, 354, 356, 3, 2, 2, 2, 355, 351, 3, 2, 2, 2, 355, 356, 3, 
	2, 2, 2, 356, 37, 3, 2, 2, 2, 357, 362, 5, 40, 21, 2, 358, 359, 7, 32, 
	2, 2, 359, 361, 5, 40, 21, 2, 360, 358, 3, 2, 2, 2, 361, 364, 3, 2, 2, 
	2, 362, 360, 3, 2, 2, 2, 362, 363, 3, 2, 2, 2, 363, 39, 3, 2, 2, 2, 364, 
	362, 3, 2, 2, 2, 365, 368, 5, 42, 22, 2, 366, 367, 7, 94, 2, 2, 367, 369, 
	5, 42, 22, 2, 368, 366, 3, 2, 2, 2, 368, 369, 3, 2, 2, 2, 369, 41, 3, 2, 
	2, 2, 370, 375, 5, 44, 23, 2, 371, 372, 9, 3, 2, 2, 372, 374, 5, 44, 23, 
	2, 373, 371, 3, 2, 2, 2, 374, 377, 3, 2, 2, 2, 375, 373, 3, 2, 2, 2, 375, 
	376, 3, 2, 2, 2, 376, 43, 3, 2, 2, 2, 377, 375, 3, 2, 2, 2, 378, 383, 5, 
	46, 24, 2, 379, 380, 9, 4, 2, 2, 380, 382, 5, 46, 24, 2, 381, 379, 3, 2, 
	2, 2, 382, 385, 3, 2, 2, 2, 383, 381, 3, 2, 2, 2, 383, 384, 3, 2, 2, 2, 
	384, 45, 3, 2, 2, 2, 385, 383, 3, 2, 2, 2, 386, 391, 5, 48, 25, 2, 387, 
	388, 9, 5, 2, 2, 388, 390, 5, 48, 25, 2, 389, 387, 3, 2, 2, 2, 390, 393, 
	3, 2, 2, 2, 391, 389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 47, 3, 2, 
	2, 2, 393, 391, 3, 2, 2, 2, 394, 399, 5, 50, 26, 2, 395, 396, 9, 6, 2, 
	2, 396, 398, 5, 50, 26, 2, 397, 395, 3, 2, 2, 2, 398, 401, 3, 2, 2, 2, 
	399, 397, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 49, 3, 2, 2, 2, 401, 399, 
	3, 2, 2, 2, 402, 406, 5, 52, 27, 2, 403, 404, 7, 67, 2, 2, 404, 405, 7, 
	80, 2, 2, 405, 407, 5, 158, 80, 2, 406, 403, 3, 2, 2, 2, 406, 407, 3, 2, 
	2, 2, 407, 51, 3, 2, 2, 2, 408, 412, 5, 54, 28, 2, 409, 410, 7, 95, 2, 
	2, 410, 411, 7, 42, 2, 2, 411, 413, 5, 158, 80, 2, 412, 409, 3, 2, 2, 2, 
	412, 413, 3, 2, 2, 2, 413, 53, 3, 2, 2, 2, 414, 418, 5, 56, 29, 2, 415, 
	416, 7, 45, 2, 2, 416, 417, 7, 42, 2, 2, 417, 419, 5, 154, 78, 2, 418, 
	415, 3, 2, 2, 2, 418, 419, 3, 2, 2, 2, 419, 55, 3, 2, 2, 2, 420, 424, 5, 
	58, 30, 2, 421, 422, 7, 44, 2, 2, 422, 423, 7, 42, 2, 2, 423, 425, 5, 154, 
	78, 2, 424, 421, 3, 2, 2, 2, 424, 425, 3, 2, 2, 2, 425, 57, 3, 2, 2, 2, 
	426, 433, 5, 60, 31, 2, 427, 428, 7, 16, 2, 2, 428, 429, 5, 110, 56, 2, 
	429, 430, 5, 100, 51, 2, 430, 432, 3, 2, 2, 2, 431, 427, 3, 2, 2, 2, 432, 
	435, 3, 2, 2, 2, 433, 431, 3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 59, 3, 
	2, 2, 2, 435, 433, 3, 2, 2, 2, 436, 438, 9, 3, 2, 2, 437, 436, 3, 2, 2, 
	2, 438, 441, 3, 2, 2, 2, 439, 437, 3, 2, 2, 2, 439, 440, 3, 2, 2, 2, 440, 
	442, 3, 2, 2, 2, 441, 439, 3, 2, 2, 2, 442, 443, 5, 62, 32, 2, 443, 61, 
	3, 2, 2, 2, 444, 445, 5, 70, 36, 2, 445, 63, 3, 2, 2, 2, 446, 447, 9, 7, 
	2, 2, 447, 65, 3, 2, 2, 2, 448, 449, 9, 8, 2, 2, 449, 67, 3, 2, 2, 2, 450, 
	451, 9, 9, 2, 2, 451, 69, 3, 2, 2, 2, 452, 457, 5, 72, 37, 2, 453, 454, 
	7, 4, 2, 2, 454, 456, 5, 72, 37, 2, 455, 453, 3, 2, 2, 2, 456, 459, 3, 
	2, 2, 2, 457, 455, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 71, 3, 2, 2, 
	2, 459, 457, 3, 2, 2, 2, 460, 462, 7, 35, 2, 2, 461, 463, 5, 74, 38, 2, 
	462, 461, 3, 2, 2, 2, 462, 463, 3, 2, 2, 2, 463, 468, 3, 2, 2, 2, 464, 
	465, 7, 36, 2, 2, 465, 468, 5, 74, 38, 2, 466, 468, 5, 74, 38, 2, 467, 
	460, 3, 2, 2, 2, 467, 464, 3, 2, 2, 2, 467, 466, 3, 2, 2, 2, 468, 73, 3, 
	2, 2, 2, 469, 474, 5, 76, 39, 2, 470, 471, 9, 10, 2, 2, 471, 473, 5, 76, 
	39, 2, 472, 470, 3, 2, 2, 2, 473, 476, 3, 2, 2, 2, 474, 472, 3, 2, 2, 2, 
	474, 475, 3, 2, 2, 2, 475, 75, 3, 2, 2, 2, 476, 474, 3, 2, 2, 2, 477, 480, 
	5, 98, 50, 2, 478, 480, 5, 78, 40, 2, 479, 477, 3, 2, 2, 2, 479, 478, 3, 
	2, 2, 2, 480, 77, 3, 2, 2, 2, 481, 484, 5, 86, 44, 2, 482, 484, 5, 80, 
	41, 2, 483, 481, 3, 2, 2, 2, 483, 482, 3, 2, 2, 2, 484, 485, 3, 2, 2, 2, 
	485, 486, 5, 102, 52, 2, 486, 79, 3, 2, 2, 2, 487, 488, 5, 82, 42, 2, 488, 
	489, 5, 92, 47, 2, 489, 492, 3, 2, 2, 2, 490, 492, 5, 84, 43, 2, 491, 487, 
	3, 2, 2, 2, 491, 490, 3, 2, 2, 2, 492, 81, 3, 2, 2, 2, 493, 494, 7, 46, 
	2, 2, 494, 510, 7, 9, 2, 2, 495, 496, 7, 48, 2, 2, 496, 510, 7, 9, 2, 2, 
	497, 498, 7, 43, 2, 2, 498, 510, 7, 9, 2, 2, 499, 500, 7, 90, 2, 2, 500, 
	510, 7, 9, 2, 2, 501, 502, 7, 49, 2, 2, 502, 510, 7, 9, 2, 2, 503, 504, 
	7, 59, 2, 2, 504, 510, 7, 9, 2, 2, 505, 506, 7, 58, 2, 2, 506, 510, 7, 
	9, 2, 2, 507, 508, 7, 76, 2, 2, 508, 510, 7, 9, 2, 2, 509, 493, 3, 2, 2, 
	2, 509, 495, 3, 2, 2, 2, 509, 497, 3, 2, 2, 2, 509, 499, 3, 2, 2, 2, 509, 
	501, 3, 2, 2, 2, 509, 503, 3, 2, 2, 2, 509, 505, 3, 2, 2, 2, 509, 507, 
	3, 2, 2, 2, 510, 83, 3, 2, 2, 2, 511, 513, 7, 3, 2, 2, 512, 511, 3, 2, 
	2, 2, 512, 513, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 515, 5, 92, 47, 
	2, 515, 85, 3, 2, 2, 2, 516, 517, 5, 88, 45, 2, 517, 518, 5, 92, 47, 2, 
	518, 521, 3, 2, 2, 2, 519, 521, 5, 90, 46, 2, 520, 516, 3, 2, 2, 2, 520, 
	519, 3, 2, 2, 2, 521, 87, 3, 2, 2, 2, 522, 523, 7, 82, 2, 2, 523, 533, 
	7, 9, 2, 2, 524, 525, 7, 38, 2, 2, 525, 533, 7, 9, 2, 2, 526, 527, 7, 84, 
	2, 2, 527, 533, 7, 9, 2, 2, 528, 529, 7, 83, 2, 2, 529, 533, 7, 9, 2, 2, 
	530, 531, 7, 39, 2, 2, 531, 533, 7, 9, 2, 2, 532, 522, 3, 2, 2, 2, 532, 
	524, 3, 2, 2, 2, 532, 526, 3, 2, 2, 2, 532, 528, 3, 2, 2, 2, 532, 530, 
	3, 2, 2, 2, 533, 89, 3, 2, 2, 2, 534, 535, 7, 14, 2, 2, 535, 91, 3, 2, 
	2, 2, 536, 539, 5, 166, 84, 2, 537, 539, 5, 94, 48, 2, 538, 536, 3, 2, 
	2, 2, 538, 537, 3, 2, 2, 2, 539, 93, 3, 2, 2, 2, 540, 543, 5, 224, 113, 
	2, 541, 543, 5, 96, 49, 2, 542, 540, 3, 2, 2, 2, 542, 541, 3, 2, 2, 2, 
	543, 95, 3, 2, 2, 2, 544, 552, 7, 37, 2, 2, 545, 546, 7, 105, 2, 2, 546, 
	552, 7, 12, 2, 2, 547, 548, 7, 34, 2, 2, 548, 552, 7, 105, 2, 2, 549, 550, 
	7, 102, 2, 2, 550, 552, 7, 37, 2, 2, 551, 544, 3, 2, 2, 2, 551, 545, 3, 
	2, 2, 2, 551, 547, 3, 2, 2, 2, 551, 549, 3, 2, 2, 2, 552, 97, 3, 2, 2, 
	2, 553, 559, 5, 112, 57, 2, 554, 558, 5, 104, 53, 2, 555, 558, 5, 100, 
	51, 2, 556, 558, 5, 106, 54, 2, 557, 554, 3, 2, 2, 2, 557, 555, 3, 2, 2, 
	2, 557, 556, 3, 2, 2, 2, 558, 561, 3, 2, 2, 2, 559, 557, 3, 2, 2, 2, 559, 
	560, 3, 2, 2, 2, 560, 99, 3, 2, 2, 2, 561, 559, 3, 2, 2, 2, 562, 571, 7, 
	28, 2, 2, 563, 568, 5, 128, 65, 2, 564, 565, 7, 10, 2, 2, 565, 567, 5, 
	128, 65, 2, 566, 564, 3, 2, 2, 2, 567, 570, 3, 2, 2, 2, 568, 566, 3, 2, 
	2, 2, 568, 569, 3, 2, 2, 2, 569, 572, 3, 2, 2, 2, 570, 568, 3, 2, 2, 2, 
	571, 563, 3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 
	574, 7, 11, 2, 2, 574, 101, 3, 2, 2, 2, 575, 577, 5, 104, 53, 2, 576, 575, 
	3, 2, 2, 2, 577, 580, 3, 2, 2, 2, 578, 576, 3, 2, 2, 2, 578, 579, 3, 2, 
	2, 2, 579, 103, 3, 2, 2, 2, 580, 578, 3, 2, 2, 2, 581, 582, 7, 26, 2, 2, 
	582, 583, 5, 12, 7, 2, 583, 584, 7, 5, 2, 2, 584, 105, 3, 2, 2, 2, 585, 
	586, 7, 33, 2, 2, 586, 587, 5, 108, 55, 2, 587, 107, 3, 2, 2, 2, 588, 593, 
	7, 105, 2, 2, 589, 593, 7, 97, 2, 2, 590, 593, 5, 122, 62, 2, 591, 593, 
	7, 37, 2, 2, 592, 588, 3, 2, 2, 2, 592, 589, 3, 2, 2, 2, 592, 590, 3, 2, 
	2, 2, 592, 591, 3, 2, 2, 2, 593, 109, 3, 2, 2, 2, 594, 598, 5, 224, 113, 
	2, 595, 598, 5, 118, 60, 2, 596, 598, 5, 122, 62, 2, 597, 594, 3, 2, 2, 
	2, 597, 595, 3, 2, 2, 2, 597, 596, 3, 2, 2, 2, 598, 111, 3, 2, 2, 2, 599, 
	609, 5, 114, 58, 2, 600, 609, 5, 118, 60, 2, 601, 609, 5, 122, 62, 2, 602, 
	609, 5, 124, 63, 2, 603, 609, 5, 126, 64, 2, 604, 609, 5, 132, 67, 2, 605, 
	609, 5, 138, 70, 2, 606, 609, 5, 146, 74, 2, 607, 609, 5, 152, 77, 2, 608, 
	599, 3, 2, 2, 2, 608, 600, 3, 2, 2, 2, 608, 601, 3, 2, 2, 2, 608, 602, 
	3, 2, 2, 2, 608, 603, 3, 2, 2, 2, 608, 604, 3, 2, 2, 2, 608, 605, 3, 2, 
	2, 2, 608, 606, 3, 2, 2, 2, 608, 607, 3, 2, 2, 2, 609, 113, 3, 2, 2, 2, 
	610, 613, 5, 116, 59, 2, 611, 613, 7, 100, 2, 2, 612, 610, 3, 2, 2, 2, 
	612, 611, 3, 2, 2, 2, 613, 115, 3, 2, 2, 2, 614, 615, 9, 11, 2, 2, 615, 
	117, 3, 2, 2, 2, 616, 617, 7, 15, 2, 2, 617, 618, 5, 120, 61, 2, 618, 119, 
	3, 2, 2, 2, 619, 620, 5, 224, 113, 2, 620, 121, 3, 2, 2, 2, 621, 623, 7, 
	28, 2, 2, 622, 624, 5, 12, 7, 2, 623, 622, 3, 2, 2, 2, 623, 624, 3, 2, 
	2, 2, 624, 625, 3, 2, 2, 2, 625, 626, 7, 11, 2, 2, 626, 123, 3, 2, 2, 2, 
	627, 628, 7, 13, 2, 2, 628, 125, 3, 2, 2, 2, 629, 630, 6, 64, 2, 2, 630, 
	631, 5, 224, 113, 2, 631, 632, 5, 100, 51, 2, 632, 127, 3, 2, 2, 2, 633, 
	636, 5, 14, 8, 2, 634, 636, 5, 130, 66, 2, 635, 633, 3, 2, 2, 2, 635, 634, 
	3, 2, 2, 2, 636, 129, 3, 2, 2, 2, 637, 638, 7, 33, 2, 2, 638, 131, 3, 2, 
	2, 2, 639, 642, 5, 134, 68, 2, 640, 642, 5, 136, 69, 2, 641, 639, 3, 2, 
	2, 2, 641, 640, 3, 2, 2, 2, 642, 133, 3, 2, 2, 2, 643, 644, 5, 224, 113, 
	2, 644, 645, 7, 31, 2, 2, 645, 646, 7, 97, 2, 2, 646, 135, 3, 2, 2, 2, 
	647, 648, 7, 61, 2, 2, 648, 650, 7, 28, 2, 2, 649, 651, 5, 4, 3, 2, 650, 
	649, 3, 2, 2, 2, 650, 651, 3, 2, 2, 2, 651, 652, 3, 2, 2, 2, 652, 655, 
	7, 11, 2, 2, 653, 654, 7, 42, 2, 2, 654, 656, 5, 158, 80, 2, 655, 653, 
	3, 2, 2, 2, 655, 656, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 658, 5, 8, 
	5, 2, 658, 137, 3, 2, 2, 2, 659, 660, 7, 74, 2, 2, 660, 669, 7, 27, 2, 
	2, 661, 666, 5, 140, 71, 2, 662, 663, 7, 10, 2, 2, 663, 665, 5, 140, 71, 
	2, 664, 662, 3, 2, 2, 2, 665, 668, 3, 2, 2, 2, 666, 664, 3, 2, 2, 2, 666, 
	667, 3, 2, 2, 2, 667, 670, 3, 2, 2, 2, 668, 666, 3, 2, 2, 2, 669, 661, 
	3, 2, 2, 2, 669, 670, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2, 671, 672, 7, 6, 
	2, 2, 672, 139, 3, 2, 2, 2, 673, 674, 5, 142, 72, 2, 674, 675, 7, 8, 2, 
	2, 675, 676, 5, 144, 73, 2, 676, 141, 3, 2, 2, 2, 677, 678, 5, 14, 8, 2, 
	678, 143, 3, 2, 2, 2, 679, 680, 5, 14, 8, 2, 680, 145, 3, 2, 2, 2, 681, 
	684, 5, 148, 75, 2, 682, 684, 5, 150, 76, 2, 683, 681, 3, 2, 2, 2, 683, 
	682, 3, 2, 2, 2, 684, 147, 3, 2, 2, 2, 685, 694, 7, 26, 2, 2, 686, 691, 
	5, 14, 8, 2, 687, 688, 7, 10, 2, 2, 688, 690, 5, 14, 8, 2, 689, 687, 3, 
	2, 2, 2, 690, 693, 3, 2, 2, 2, 691, 689, 3, 2, 2, 2, 691, 692, 3, 2, 2, 
	2, 692, 695, 3, 2, 2, 2, 693, 691, 3, 2, 2, 2, 694, 686, 3, 2, 2, 2, 694, 
	695, 3, 2, 2, 2, 695, 696, 3, 2, 2, 2, 696, 697, 7, 5, 2, 2, 697, 149, 
	3, 2, 2, 2, 698, 699, 7, 41, 2, 2, 699, 700, 5, 10, 6, 2, 700, 151, 3, 
	2, 2, 2, 701, 702, 7, 33, 2, 2, 702, 703, 5, 108, 55, 2, 703, 153, 3, 2, 
	2, 2, 704, 706, 5, 200, 101, 2, 705, 707, 7, 33, 2, 2, 706, 705, 3, 2, 
	2, 2, 706, 707, 3, 2, 2, 2, 707, 155, 3, 2, 2, 2, 708, 709, 7, 42, 2, 2, 
	709, 710, 5, 158, 80, 2, 710, 157, 3, 2, 2, 2, 711, 712, 7, 54, 2, 2, 712, 
	713, 7, 28, 2, 2, 713, 719, 7, 11, 2, 2, 714, 716, 5, 162, 82, 2, 715, 
	717, 5, 160, 81, 2, 716, 715, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2, 717, 719, 
	3, 2, 2, 2, 718, 711, 3, 2, 2, 2, 718, 714, 3, 2, 2, 2, 719, 159, 3, 2, 
	2, 2, 720, 721, 9, 12, 2, 2, 721, 161, 3, 2, 2, 2, 722, 732, 5, 166, 84, 
	2, 723, 724, 7, 70, 2, 2, 724, 725, 7, 28, 2, 2, 725, 732, 7, 11, 2, 2, 
	726, 732, 5, 204, 103, 2, 727, 732, 5, 210, 106, 2, 728, 732, 5, 216, 109, 
	2, 729, 732, 5, 164, 83, 2, 730, 732, 5, 222, 112, 2, 731, 722, 3, 2, 2, 
	2, 731, 723, 3, 2, 2, 2, 731, 726, 3, 2, 2, 2, 731, 727, 3, 2, 2, 2, 731, 
	728, 3, 2, 2, 2, 731, 729, 3, 2, 2, 2, 731, 730, 3, 2, 2, 2, 732, 163, 
	3, 2, 2, 2, 733, 734, 5, 224, 113, 2, 734, 165, 3, 2, 2, 2, 735, 746, 5, 
	170, 86, 2, 736, 746, 5, 188, 95, 2, 737, 746, 5, 180, 91, 2, 738, 746, 
	5, 192, 97, 2, 739, 746, 5, 184, 93, 2, 740, 746, 5, 178, 90, 2, 741, 746, 
	5, 174, 88, 2, 742, 746, 5, 172, 87, 2, 743, 746, 5, 176, 89, 2, 744, 746, 
	5, 168, 85, 2, 745, 735, 3, 2, 2, 2, 745, 736, 3, 2, 2, 2, 745, 737, 3, 
	2, 2, 2, 745, 738, 3, 2, 2, 2, 745, 739, 3, 2, 2, 2, 745, 740, 3, 2, 2, 
	2, 745, 741, 3, 2, 2, 2, 745, 742, 3, 2, 2, 2, 745, 743, 3, 2, 2, 2, 745, 
	744, 3, 2, 2, 2, 746, 167, 3, 2, 2, 2, 747, 748, 7, 79, 2, 2, 748, 749, 
	7, 28, 2, 2, 749, 750, 7, 11, 2, 2, 750, 169, 3, 2, 2, 2, 751, 752, 7, 
	51, 2, 2, 752, 755, 7, 28, 2, 2, 753, 756, 5, 188, 95, 2, 754, 756, 5, 
	192, 97, 2, 755, 753, 3, 2, 2, 2, 755, 754, 3, 2, 2, 2, 755, 756, 3, 2, 
	2, 2, 756, 757, 3, 2, 2, 2, 757, 758, 7, 11, 2, 2, 758, 171, 3, 2, 2, 2, 
	759, 760, 7, 92, 2, 2, 760, 761, 7, 28, 2, 2, 761, 762, 7, 11, 2, 2, 762, 
	173, 3, 2, 2, 2, 763, 764, 7, 47, 2, 2, 764, 765, 7, 28, 2, 2, 765, 766, 
	7, 11, 2, 2, 766, 175, 3, 2, 2, 2, 767, 768, 7, 77, 2, 2, 768, 769, 7, 
	28, 2, 2, 769, 770, 7, 11, 2, 2, 770, 177, 3, 2, 2, 2, 771, 772, 7, 85, 
	2, 2, 772, 774, 7, 28, 2, 2, 773, 775, 9, 13, 2, 2, 774, 773, 3, 2, 2, 
	2, 774, 775, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 777, 7, 11, 2, 2, 777, 
	179, 3, 2, 2, 2, 778, 779, 7, 43, 2, 2, 779, 785, 7, 28, 2, 2, 780, 783, 
	5, 182, 92, 2, 781, 782, 7, 10, 2, 2, 782, 784, 5, 202, 102, 2, 783, 781, 
	3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784, 786, 3, 2, 2, 2, 785, 780, 3, 2, 
	2, 2, 785, 786, 3, 2, 2, 2, 786, 787, 3, 2, 2, 2, 787, 788, 7, 11, 2, 2, 
	788, 181, 3, 2, 2, 2, 789, 792, 5, 196, 99, 2, 790, 792, 7, 37, 2, 2, 791, 
	789, 3, 2, 2, 2, 791, 790, 3, 2, 2, 2, 792, 183, 3, 2, 2, 2, 793, 794, 
	7, 88, 2, 2, 794, 795, 7, 28, 2, 2, 795, 796, 5, 186, 94, 2, 796, 797, 
	7, 11, 2, 2, 797, 185, 3, 2, 2, 2, 798, 799, 5, 196, 99, 2, 799, 187, 3, 
	2, 2, 2, 800, 801, 7, 52, 2, 2, 801, 810, 7, 28, 2, 2, 802, 808, 5, 190, 
	96, 2, 803, 804, 7, 10, 2, 2, 804, 806, 5, 202, 102, 2, 805, 807, 7, 33, 
	2, 2, 806, 805, 3, 2, 2, 2, 806, 807, 3, 2, 2, 2, 807, 809, 3, 2, 2, 2, 
	808, 803, 3, 2, 2, 2, 808, 809, 3, 2, 2, 2, 809, 811, 3, 2, 2, 2, 810, 
	802, 3, 2, 2, 2, 810, 811, 3, 2, 2, 2, 811, 812, 3, 2, 2, 2, 812, 813, 
	7, 11, 2, 2, 813, 189, 3, 2, 2, 2, 814, 817, 5, 198, 100, 2, 815, 817, 
	7, 37, 2, 2, 816, 814, 3, 2, 2, 2, 816, 815, 3, 2, 2, 2, 817, 191, 3, 2, 
	2, 2, 818, 819, 7, 89, 2, 2, 819, 820, 7, 28, 2, 2, 820, 821, 5, 194, 98, 
	2, 821, 822, 7, 11, 2, 2, 822, 193, 3, 2, 2, 2, 823, 824, 5, 198, 100, 
	2, 824, 195, 3, 2, 2, 2, 825, 826, 5, 224, 113, 2, 826, 197, 3, 2, 2, 2, 
	827, 828, 5, 224, 113, 2, 828, 199, 3, 2, 2, 2, 829, 830, 5, 202, 102, 
	2, 830, 201, 3, 2, 2, 2, 831, 832, 5, 224, 113, 2, 832, 203, 3, 2, 2, 2, 
	833, 836, 5, 206, 104, 2, 834, 836, 5, 208, 105, 2, 835, 833, 3, 2, 2, 
	2, 835, 834, 3, 2, 2, 2, 836, 205, 3, 2, 2, 2, 837, 838, 7, 61, 2, 2, 838, 
	839, 7, 28, 2, 2, 839, 840, 7, 37, 2, 2, 840, 841, 7, 11, 2, 2, 841, 207, 
	3, 2, 2, 2, 842, 843, 7, 61, 2, 2, 843, 852, 7, 28, 2, 2, 844, 849, 5, 
	158, 80, 2, 845, 846, 7, 10, 2, 2, 846, 848, 5, 158, 80, 2, 847, 845, 3, 
	2, 2, 2, 848, 851, 3, 2, 2, 2, 849, 847, 3, 2, 2, 2, 849, 850, 3, 2, 2, 
	2, 850, 853, 3, 2, 2, 2, 851, 849, 3, 2, 2, 2, 852, 844, 3, 2, 2, 2, 852, 
	853, 3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 855, 7, 11, 2, 2, 855, 856, 
	7, 42, 2, 2, 856, 857, 5, 158, 80, 2, 857, 209, 3, 2, 2, 2, 858, 861, 5, 
	212, 107, 2, 859, 861, 5, 214, 108, 2, 860, 858, 3, 2, 2, 2, 860, 859, 
	3, 2, 2, 2, 861, 211, 3, 2, 2, 2, 862, 863, 7, 74, 2, 2, 863, 864, 7, 28, 
	2, 2, 864, 865, 7, 37, 2, 2, 865, 866, 7, 11, 2, 2, 866, 213, 3, 2, 2, 
	2, 867, 868, 7, 74, 2, 2, 868, 869, 7, 28, 2, 2, 869, 870, 5, 164, 83, 
	2, 870, 871, 7, 10, 2, 2, 871, 872, 5, 158, 80, 2, 872, 873, 7, 11, 2, 
	2, 873, 215, 3, 2, 2, 2, 874, 877, 5, 218, 110, 2, 875, 877, 5, 220, 111, 
	2, 876, 874, 3, 2, 2, 2, 876, 875, 3, 2, 2, 2, 877, 217, 3, 2, 2, 2, 878, 
	879, 7, 41, 2, 2, 879, 880, 7, 28, 2, 2, 880, 881, 7, 37, 2, 2, 881, 882, 
	7, 11, 2, 2, 882, 219, 3, 2, 2, 2, 883, 884, 7, 41, 2, 2, 884, 885, 7, 
	28, 2, 2, 885, 886, 5, 158, 80, 2, 886, 887, 7, 11, 2, 2, 887, 221, 3, 
	2, 2, 2, 888, 889, 7, 28, 2, 2, 889, 890, 5, 162, 82, 2, 890, 891, 7, 11, 
	2, 2, 891, 223, 3, 2, 2, 2, 892, 893, 9, 14, 2, 2, 893, 225, 3, 2, 2, 2, 
	894, 895, 5, 12, 7, 2, 895, 896, 7, 107, 2, 2, 896, 898, 3, 2, 2, 2, 897, 
	894, 3, 2, 2, 2, 898, 899, 3, 2, 2, 2, 899, 897, 3, 2, 2, 2, 899, 900, 
	3, 2, 2, 2, 900, 901, 3, 2, 2, 2, 901, 902, 7, 2, 2, 3, 902, 227, 3, 2, 
	2, 2, 79, 236, 242, 248, 257, 265, 277, 295, 316, 336, 344, 351, 355, 362, 
	368, 375, 383, 391, 399, 406, 412, 418, 424, 433, 439, 457, 462, 467, 474, 
	479, 483, 491, 509, 512, 520, 532, 538, 542, 551, 557, 559, 568, 571, 578, 
	592, 597, 608, 612, 623, 635, 641, 650, 655, 666, 669, 683, 691, 694, 706, 
	716, 718, 731, 745, 755, 774, 783, 785, 791, 806, 808, 810, 816, 835, 849, 
	852, 860, 876, 899,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'@'", "'!'", "']'", "'}'", "':='", "':'", "'::'", "','", "')'", "':*'", 
	"'.'", "'..'", "'$'", "'=>'", "'='", "'>='", "'>>'", "'>'", "'<='", "'<<'", 
	"'<'", "'-'", "'!='", "'['", "'{'", "'('", "'|'", "'+'", "'#'", "'||'", 
	"'?'", "'*:'", "'/'", "'//'", "'*'", "'ancestor'", "'ancestor-or-self'", 
	"'and'", "'array'", "'as'", "'attribute'", "'cast'", "'castable'", "'child'", 
	"'comment'", "'descendant'", "'descendant-or-self'", "'div'", "'document-node'", 
	"'element'", "'else'", "'empty-sequence'", "'eq'", "'every'", "'except'", 
	"'following'", "'following-sibling'", "'for'", "'function'", "'ge'", "'gt'", 
	"'idiv'", "'if'", "'in'", "'instance'", "'intersect'", "'is'", "'item'", 
	"'le'", "'let'", "'lt'", "'map'", "'mod'", "'namespace'", "'namespace-node'", 
	"'ne'", "'node'", "'of'", "'or'", "'parent'", "'preceding'", "'preceding-sibling'", 
	"'processing-instruction'", "'return'", "'satisfies'", "'schema-attribute'", 
	"'schema-element'", "'self'", "'some'", "'text'", "'then'", "'to'", "'treat'", 
	"'union'", "", "", "", "", "", "", "", "", "", "", "';'",
}
var symbolicNames = []string{
	"", "AT", "BANG", "CB", "CC", "CEQ", "COLON", "COLONCOLON", "COMMA", "CP", 
	"CS", "D", "DD", "DOLLAR", "EG", "EQ", "GE", "GG", "GT", "LE", "LL", "LT", 
	"MINUS", "NE", "OB", "OC", "OP", "P", "PLUS", "POUND", "PP", "QM", "SC", 
	"SLASH", "SS", "STAR", "KW_ANCESTOR", "KW_ANCESTOR_OR_SELF", "KW_AND", 
	"KW_ARRAY", "KW_AS", "KW_ATTRIBUTE", "KW_CAST", "KW_CASTABLE", "KW_CHILD", 
	"KW_COMMENT", "KW_DESCENDANT", "KW_DESCENDANT_OR_SELF", "KW_DIV", "KW_DOCUMENT_NODE", 
	"KW_ELEMENT", "KW_ELSE", "KW_EMPTY_SEQUENCE", "KW_EQ", "KW_EVERY", "KW_EXCEPT", 
	"KW_FOLLOWING", "KW_FOLLOWING_SIBLING", "KW_FOR", "KW_FUNCTION", "KW_GE", 
	"KW_GT", "KW_IDIV", "KW_IF", "KW_IN", "KW_INSTANCE", "KW_INTERSECT", "KW_IS", 
	"KW_ITEM", "KW_LE", "KW_LET", "KW_LT", "KW_MAP", "KW_MOD", "KW_NAMESPACE", 
	"KW_NAMESPACE_NODE", "KW_NE", "KW_NODE", "KW_OF", "KW_OR", "KW_PARENT", 
	"KW_PRECEDING", "KW_PRECEDING_SIBLING", "KW_PROCESSING_INSTRUCTION", "KW_RETURN", 
	"KW_SATISFIES", "KW_SCHEMA_ATTRIBUTE", "KW_SCHEMA_ELEMENT", "KW_SELF", 
	"KW_SOME", "KW_TEXT", "KW_THEN", "KW_TO", "KW_TREAT", "KW_UNION", "IntegerLiteral", 
	"DecimalLiteral", "DoubleLiteral", "StringLiteral", "URIQualifiedName", 
	"BracedURILiteral", "Comment", "QName", "NCName", "Whitespace", "SEMI",
}

var ruleNames = []string{
	"xpath", "paramlist", "param", "functionbody", "enclosedexpr", "expr", 
	"exprsingle", "forexpr", "simpleforclause", "simpleforbinding", "letexpr", 
	"simpleletclause", "simpleletbinding", "quantifiedexpr", "ifexpr", "orexpr", 
	"andexpr", "comparisonexpr", "stringconcatexpr", "rangeexpr", "additiveexpr", 
	"multiplicativeexpr", "unionexpr", "intersectexceptexpr", "instanceofexpr", 
	"treatexpr", "castableexpr", "castexpr", "arrowexpr", "unaryexpr", "valueexpr", 
	"generalcomp", "valuecomp", "nodecomp", "simplemapexpr", "pathexpr", "relativepathexpr", 
	"stepexpr", "axisstep", "forwardstep", "forwardaxis", "abbrevforwardstep", 
	"reversestep", "reverseaxis", "abbrevreversestep", "nodetest", "nametest", 
	"wildcard", "postfixexpr", "argumentlist", "predicatelist", "predicate", 
	"lookup", "keyspecifier", "arrowfunctionspecifier", "primaryexpr", "literal", 
	"numericliteral", "varref", "varname", "parenthesizedexpr", "contextitemexpr", 
	"functioncall", "argument", "argumentplaceholder", "functionitemexpr", 
	"namedfunctionref", "inlinefunctionexpr", "mapconstructor", "mapconstructorentry", 
	"mapkeyexpr", "mapvalueexpr", "arrayconstructor", "squarearrayconstructor", 
	"curlyarrayconstructor", "unarylookup", "singletype", "typedeclaration", 
	"sequencetype", "occurrenceindicator", "itemtype", "atomicoruniontype", 
	"kindtest", "anykindtest", "documenttest", "texttest", "commenttest", "namespacenodetest", 
	"pitest", "attributetest", "attribnameorwildcard", "schemaattributetest", 
	"attributedeclaration", "elementtest", "elementnameorwildcard", "schemaelementtest", 
	"elementdeclaration", "attributename", "elementname", "simpletypename", 
	"typename", "functiontest", "anyfunctiontest", "typedfunctiontest", "maptest", 
	"anymaptest", "typedmaptest", "arraytest", "anyarraytest", "typedarraytest", 
	"parenthesizeditemtype", "eqname", "auxilary",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type XPath31Parser struct {
	*antlr.BaseParser
}

func NewXPath31Parser(input antlr.TokenStream) *XPath31Parser {
	this := new(XPath31Parser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "XPath31.g4"

	return this
}

// XPath31Parser tokens.
const (
	XPath31ParserEOF = antlr.TokenEOF
	XPath31ParserAT = 1
	XPath31ParserBANG = 2
	XPath31ParserCB = 3
	XPath31ParserCC = 4
	XPath31ParserCEQ = 5
	XPath31ParserCOLON = 6
	XPath31ParserCOLONCOLON = 7
	XPath31ParserCOMMA = 8
	XPath31ParserCP = 9
	XPath31ParserCS = 10
	XPath31ParserD = 11
	XPath31ParserDD = 12
	XPath31ParserDOLLAR = 13
	XPath31ParserEG = 14
	XPath31ParserEQ = 15
	XPath31ParserGE = 16
	XPath31ParserGG = 17
	XPath31ParserGT = 18
	XPath31ParserLE = 19
	XPath31ParserLL = 20
	XPath31ParserLT = 21
	XPath31ParserMINUS = 22
	XPath31ParserNE = 23
	XPath31ParserOB = 24
	XPath31ParserOC = 25
	XPath31ParserOP = 26
	XPath31ParserP = 27
	XPath31ParserPLUS = 28
	XPath31ParserPOUND = 29
	XPath31ParserPP = 30
	XPath31ParserQM = 31
	XPath31ParserSC = 32
	XPath31ParserSLASH = 33
	XPath31ParserSS = 34
	XPath31ParserSTAR = 35
	XPath31ParserKW_ANCESTOR = 36
	XPath31ParserKW_ANCESTOR_OR_SELF = 37
	XPath31ParserKW_AND = 38
	XPath31ParserKW_ARRAY = 39
	XPath31ParserKW_AS = 40
	XPath31ParserKW_ATTRIBUTE = 41
	XPath31ParserKW_CAST = 42
	XPath31ParserKW_CASTABLE = 43
	XPath31ParserKW_CHILD = 44
	XPath31ParserKW_COMMENT = 45
	XPath31ParserKW_DESCENDANT = 46
	XPath31ParserKW_DESCENDANT_OR_SELF = 47
	XPath31ParserKW_DIV = 48
	XPath31ParserKW_DOCUMENT_NODE = 49
	XPath31ParserKW_ELEMENT = 50
	XPath31ParserKW_ELSE = 51
	XPath31ParserKW_EMPTY_SEQUENCE = 52
	XPath31ParserKW_EQ = 53
	XPath31ParserKW_EVERY = 54
	XPath31ParserKW_EXCEPT = 55
	XPath31ParserKW_FOLLOWING = 56
	XPath31ParserKW_FOLLOWING_SIBLING = 57
	XPath31ParserKW_FOR = 58
	XPath31ParserKW_FUNCTION = 59
	XPath31ParserKW_GE = 60
	XPath31ParserKW_GT = 61
	XPath31ParserKW_IDIV = 62
	XPath31ParserKW_IF = 63
	XPath31ParserKW_IN = 64
	XPath31ParserKW_INSTANCE = 65
	XPath31ParserKW_INTERSECT = 66
	XPath31ParserKW_IS = 67
	XPath31ParserKW_ITEM = 68
	XPath31ParserKW_LE = 69
	XPath31ParserKW_LET = 70
	XPath31ParserKW_LT = 71
	XPath31ParserKW_MAP = 72
	XPath31ParserKW_MOD = 73
	XPath31ParserKW_NAMESPACE = 74
	XPath31ParserKW_NAMESPACE_NODE = 75
	XPath31ParserKW_NE = 76
	XPath31ParserKW_NODE = 77
	XPath31ParserKW_OF = 78
	XPath31ParserKW_OR = 79
	XPath31ParserKW_PARENT = 80
	XPath31ParserKW_PRECEDING = 81
	XPath31ParserKW_PRECEDING_SIBLING = 82
	XPath31ParserKW_PROCESSING_INSTRUCTION = 83
	XPath31ParserKW_RETURN = 84
	XPath31ParserKW_SATISFIES = 85
	XPath31ParserKW_SCHEMA_ATTRIBUTE = 86
	XPath31ParserKW_SCHEMA_ELEMENT = 87
	XPath31ParserKW_SELF = 88
	XPath31ParserKW_SOME = 89
	XPath31ParserKW_TEXT = 90
	XPath31ParserKW_THEN = 91
	XPath31ParserKW_TO = 92
	XPath31ParserKW_TREAT = 93
	XPath31ParserKW_UNION = 94
	XPath31ParserIntegerLiteral = 95
	XPath31ParserDecimalLiteral = 96
	XPath31ParserDoubleLiteral = 97
	XPath31ParserStringLiteral = 98
	XPath31ParserURIQualifiedName = 99
	XPath31ParserBracedURILiteral = 100
	XPath31ParserComment = 101
	XPath31ParserQName = 102
	XPath31ParserNCName = 103
	XPath31ParserWhitespace = 104
	XPath31ParserSEMI = 105
)

// XPath31Parser rules.
const (
	XPath31ParserRULE_xpath = 0
	XPath31ParserRULE_paramlist = 1
	XPath31ParserRULE_param = 2
	XPath31ParserRULE_functionbody = 3
	XPath31ParserRULE_enclosedexpr = 4
	XPath31ParserRULE_expr = 5
	XPath31ParserRULE_exprsingle = 6
	XPath31ParserRULE_forexpr = 7
	XPath31ParserRULE_simpleforclause = 8
	XPath31ParserRULE_simpleforbinding = 9
	XPath31ParserRULE_letexpr = 10
	XPath31ParserRULE_simpleletclause = 11
	XPath31ParserRULE_simpleletbinding = 12
	XPath31ParserRULE_quantifiedexpr = 13
	XPath31ParserRULE_ifexpr = 14
	XPath31ParserRULE_orexpr = 15
	XPath31ParserRULE_andexpr = 16
	XPath31ParserRULE_comparisonexpr = 17
	XPath31ParserRULE_stringconcatexpr = 18
	XPath31ParserRULE_rangeexpr = 19
	XPath31ParserRULE_additiveexpr = 20
	XPath31ParserRULE_multiplicativeexpr = 21
	XPath31ParserRULE_unionexpr = 22
	XPath31ParserRULE_intersectexceptexpr = 23
	XPath31ParserRULE_instanceofexpr = 24
	XPath31ParserRULE_treatexpr = 25
	XPath31ParserRULE_castableexpr = 26
	XPath31ParserRULE_castexpr = 27
	XPath31ParserRULE_arrowexpr = 28
	XPath31ParserRULE_unaryexpr = 29
	XPath31ParserRULE_valueexpr = 30
	XPath31ParserRULE_generalcomp = 31
	XPath31ParserRULE_valuecomp = 32
	XPath31ParserRULE_nodecomp = 33
	XPath31ParserRULE_simplemapexpr = 34
	XPath31ParserRULE_pathexpr = 35
	XPath31ParserRULE_relativepathexpr = 36
	XPath31ParserRULE_stepexpr = 37
	XPath31ParserRULE_axisstep = 38
	XPath31ParserRULE_forwardstep = 39
	XPath31ParserRULE_forwardaxis = 40
	XPath31ParserRULE_abbrevforwardstep = 41
	XPath31ParserRULE_reversestep = 42
	XPath31ParserRULE_reverseaxis = 43
	XPath31ParserRULE_abbrevreversestep = 44
	XPath31ParserRULE_nodetest = 45
	XPath31ParserRULE_nametest = 46
	XPath31ParserRULE_wildcard = 47
	XPath31ParserRULE_postfixexpr = 48
	XPath31ParserRULE_argumentlist = 49
	XPath31ParserRULE_predicatelist = 50
	XPath31ParserRULE_predicate = 51
	XPath31ParserRULE_lookup = 52
	XPath31ParserRULE_keyspecifier = 53
	XPath31ParserRULE_arrowfunctionspecifier = 54
	XPath31ParserRULE_primaryexpr = 55
	XPath31ParserRULE_literal = 56
	XPath31ParserRULE_numericliteral = 57
	XPath31ParserRULE_varref = 58
	XPath31ParserRULE_varname = 59
	XPath31ParserRULE_parenthesizedexpr = 60
	XPath31ParserRULE_contextitemexpr = 61
	XPath31ParserRULE_functioncall = 62
	XPath31ParserRULE_argument = 63
	XPath31ParserRULE_argumentplaceholder = 64
	XPath31ParserRULE_functionitemexpr = 65
	XPath31ParserRULE_namedfunctionref = 66
	XPath31ParserRULE_inlinefunctionexpr = 67
	XPath31ParserRULE_mapconstructor = 68
	XPath31ParserRULE_mapconstructorentry = 69
	XPath31ParserRULE_mapkeyexpr = 70
	XPath31ParserRULE_mapvalueexpr = 71
	XPath31ParserRULE_arrayconstructor = 72
	XPath31ParserRULE_squarearrayconstructor = 73
	XPath31ParserRULE_curlyarrayconstructor = 74
	XPath31ParserRULE_unarylookup = 75
	XPath31ParserRULE_singletype = 76
	XPath31ParserRULE_typedeclaration = 77
	XPath31ParserRULE_sequencetype = 78
	XPath31ParserRULE_occurrenceindicator = 79
	XPath31ParserRULE_itemtype = 80
	XPath31ParserRULE_atomicoruniontype = 81
	XPath31ParserRULE_kindtest = 82
	XPath31ParserRULE_anykindtest = 83
	XPath31ParserRULE_documenttest = 84
	XPath31ParserRULE_texttest = 85
	XPath31ParserRULE_commenttest = 86
	XPath31ParserRULE_namespacenodetest = 87
	XPath31ParserRULE_pitest = 88
	XPath31ParserRULE_attributetest = 89
	XPath31ParserRULE_attribnameorwildcard = 90
	XPath31ParserRULE_schemaattributetest = 91
	XPath31ParserRULE_attributedeclaration = 92
	XPath31ParserRULE_elementtest = 93
	XPath31ParserRULE_elementnameorwildcard = 94
	XPath31ParserRULE_schemaelementtest = 95
	XPath31ParserRULE_elementdeclaration = 96
	XPath31ParserRULE_attributename = 97
	XPath31ParserRULE_elementname = 98
	XPath31ParserRULE_simpletypename = 99
	XPath31ParserRULE_typename = 100
	XPath31ParserRULE_functiontest = 101
	XPath31ParserRULE_anyfunctiontest = 102
	XPath31ParserRULE_typedfunctiontest = 103
	XPath31ParserRULE_maptest = 104
	XPath31ParserRULE_anymaptest = 105
	XPath31ParserRULE_typedmaptest = 106
	XPath31ParserRULE_arraytest = 107
	XPath31ParserRULE_anyarraytest = 108
	XPath31ParserRULE_typedarraytest = 109
	XPath31ParserRULE_parenthesizeditemtype = 110
	XPath31ParserRULE_eqname = 111
	XPath31ParserRULE_auxilary = 112
)

// IXpathContext is an interface to support dynamic dispatch.
type IXpathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXpathContext differentiates from other interfaces.
	IsXpathContext()
}

type XpathContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXpathContext() *XpathContext {
	var p = new(XpathContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_xpath
	return p
}

func (*XpathContext) IsXpathContext() {}

func NewXpathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XpathContext {
	var p = new(XpathContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_xpath

	return p
}

func (s *XpathContext) GetParser() antlr.Parser { return s.parser }

func (s *XpathContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *XpathContext) EOF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserEOF, 0)
}

func (s *XpathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XpathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *XpathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterXpath(s)
	}
}

func (s *XpathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitXpath(s)
	}
}




func (p *XPath31Parser) Xpath() (localctx IXpathContext) {
	localctx = NewXpathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, XPath31ParserRULE_xpath)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Expr()
	}
	{
		p.SetState(227)
		p.Match(XPath31ParserEOF)
	}



	return localctx
}


// IParamlistContext is an interface to support dynamic dispatch.
type IParamlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamlistContext differentiates from other interfaces.
	IsParamlistContext()
}

type ParamlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamlistContext() *ParamlistContext {
	var p = new(ParamlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_paramlist
	return p
}

func (*ParamlistContext) IsParamlistContext() {}

func NewParamlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamlistContext {
	var p = new(ParamlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_paramlist

	return p
}

func (s *ParamlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamlistContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *ParamlistContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *ParamlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *ParamlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParamlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterParamlist(s)
	}
}

func (s *ParamlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitParamlist(s)
	}
}




func (p *XPath31Parser) Paramlist() (localctx IParamlistContext) {
	localctx = NewParamlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, XPath31ParserRULE_paramlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.Param()
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserCOMMA {
		{
			p.SetState(230)
			p.Match(XPath31ParserCOMMA)
		}
		{
			p.SetState(231)
			p.Param()
		}


		p.SetState(236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserDOLLAR, 0)
}

func (s *ParamContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *ParamContext) Typedeclaration() ITypedeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedeclarationContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitParam(s)
	}
}




func (p *XPath31Parser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, XPath31ParserRULE_param)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(237)
		p.Match(XPath31ParserDOLLAR)
	}
	{
		p.SetState(238)
		p.Eqname()
	}
	p.SetState(240)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserKW_AS {
		{
			p.SetState(239)
			p.Typedeclaration()
		}

	}



	return localctx
}


// IFunctionbodyContext is an interface to support dynamic dispatch.
type IFunctionbodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionbodyContext differentiates from other interfaces.
	IsFunctionbodyContext()
}

type FunctionbodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionbodyContext() *FunctionbodyContext {
	var p = new(FunctionbodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_functionbody
	return p
}

func (*FunctionbodyContext) IsFunctionbodyContext() {}

func NewFunctionbodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionbodyContext {
	var p = new(FunctionbodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_functionbody

	return p
}

func (s *FunctionbodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionbodyContext) Enclosedexpr() IEnclosedexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnclosedexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnclosedexprContext)
}

func (s *FunctionbodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionbodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionbodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterFunctionbody(s)
	}
}

func (s *FunctionbodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitFunctionbody(s)
	}
}




func (p *XPath31Parser) Functionbody() (localctx IFunctionbodyContext) {
	localctx = NewFunctionbodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, XPath31ParserRULE_functionbody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Enclosedexpr()
	}



	return localctx
}


// IEnclosedexprContext is an interface to support dynamic dispatch.
type IEnclosedexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnclosedexprContext differentiates from other interfaces.
	IsEnclosedexprContext()
}

type EnclosedexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnclosedexprContext() *EnclosedexprContext {
	var p = new(EnclosedexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_enclosedexpr
	return p
}

func (*EnclosedexprContext) IsEnclosedexprContext() {}

func NewEnclosedexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnclosedexprContext {
	var p = new(EnclosedexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_enclosedexpr

	return p
}

func (s *EnclosedexprContext) GetParser() antlr.Parser { return s.parser }

func (s *EnclosedexprContext) OC() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOC, 0)
}

func (s *EnclosedexprContext) CC() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCC, 0)
}

func (s *EnclosedexprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *EnclosedexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnclosedexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EnclosedexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterEnclosedexpr(s)
	}
}

func (s *EnclosedexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitEnclosedexpr(s)
	}
}




func (p *XPath31Parser) Enclosedexpr() (localctx IEnclosedexprContext) {
	localctx = NewEnclosedexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, XPath31ParserRULE_enclosedexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(244)
		p.Match(XPath31ParserOC)
	}
	p.SetState(246)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(245)
			p.Expr()
		}


	}
	{
		p.SetState(248)
		p.Match(XPath31ParserCC)
	}



	return localctx
}


// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_expr
	return p
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllExprsingle() []IExprsingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprsingleContext)(nil)).Elem())
	var tst = make([]IExprsingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprsingleContext)
		}
	}

	return tst
}

func (s *ExprContext) Exprsingle(i int) IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *ExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *ExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitExpr(s)
	}
}




func (p *XPath31Parser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, XPath31ParserRULE_expr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(250)
		p.Exprsingle()
	}
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserCOMMA {
		{
			p.SetState(251)
			p.Match(XPath31ParserCOMMA)
		}
		{
			p.SetState(252)
			p.Exprsingle()
		}


		p.SetState(257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IExprsingleContext is an interface to support dynamic dispatch.
type IExprsingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExprsingleContext differentiates from other interfaces.
	IsExprsingleContext()
}

type ExprsingleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprsingleContext() *ExprsingleContext {
	var p = new(ExprsingleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_exprsingle
	return p
}

func (*ExprsingleContext) IsExprsingleContext() {}

func NewExprsingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprsingleContext {
	var p = new(ExprsingleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_exprsingle

	return p
}

func (s *ExprsingleContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprsingleContext) Forexpr() IForexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForexprContext)
}

func (s *ExprsingleContext) Letexpr() ILetexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILetexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILetexprContext)
}

func (s *ExprsingleContext) Quantifiedexpr() IQuantifiedexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuantifiedexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuantifiedexprContext)
}

func (s *ExprsingleContext) Ifexpr() IIfexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfexprContext)
}

func (s *ExprsingleContext) Orexpr() IOrexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrexprContext)
}

func (s *ExprsingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprsingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExprsingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterExprsingle(s)
	}
}

func (s *ExprsingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitExprsingle(s)
	}
}




func (p *XPath31Parser) Exprsingle() (localctx IExprsingleContext) {
	localctx = NewExprsingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, XPath31ParserRULE_exprsingle)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(258)
			p.Forexpr()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(259)
			p.Letexpr()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(260)
			p.Quantifiedexpr()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(261)
			p.Ifexpr()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(262)
			p.Orexpr()
		}

	}


	return localctx
}


// IForexprContext is an interface to support dynamic dispatch.
type IForexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForexprContext differentiates from other interfaces.
	IsForexprContext()
}

type ForexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForexprContext() *ForexprContext {
	var p = new(ForexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_forexpr
	return p
}

func (*ForexprContext) IsForexprContext() {}

func NewForexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForexprContext {
	var p = new(ForexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_forexpr

	return p
}

func (s *ForexprContext) GetParser() antlr.Parser { return s.parser }

func (s *ForexprContext) Simpleforclause() ISimpleforclauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleforclauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleforclauseContext)
}

func (s *ForexprContext) KW_RETURN() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_RETURN, 0)
}

func (s *ForexprContext) Exprsingle() IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *ForexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterForexpr(s)
	}
}

func (s *ForexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitForexpr(s)
	}
}




func (p *XPath31Parser) Forexpr() (localctx IForexprContext) {
	localctx = NewForexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, XPath31ParserRULE_forexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(265)
		p.Simpleforclause()
	}
	{
		p.SetState(266)
		p.Match(XPath31ParserKW_RETURN)
	}
	{
		p.SetState(267)
		p.Exprsingle()
	}



	return localctx
}


// ISimpleforclauseContext is an interface to support dynamic dispatch.
type ISimpleforclauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleforclauseContext differentiates from other interfaces.
	IsSimpleforclauseContext()
}

type SimpleforclauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleforclauseContext() *SimpleforclauseContext {
	var p = new(SimpleforclauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_simpleforclause
	return p
}

func (*SimpleforclauseContext) IsSimpleforclauseContext() {}

func NewSimpleforclauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleforclauseContext {
	var p = new(SimpleforclauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_simpleforclause

	return p
}

func (s *SimpleforclauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleforclauseContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FOR, 0)
}

func (s *SimpleforclauseContext) AllSimpleforbinding() []ISimpleforbindingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleforbindingContext)(nil)).Elem())
	var tst = make([]ISimpleforbindingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleforbindingContext)
		}
	}

	return tst
}

func (s *SimpleforclauseContext) Simpleforbinding(i int) ISimpleforbindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleforbindingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleforbindingContext)
}

func (s *SimpleforclauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *SimpleforclauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *SimpleforclauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleforclauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleforclauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSimpleforclause(s)
	}
}

func (s *SimpleforclauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSimpleforclause(s)
	}
}




func (p *XPath31Parser) Simpleforclause() (localctx ISimpleforclauseContext) {
	localctx = NewSimpleforclauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, XPath31ParserRULE_simpleforclause)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.Match(XPath31ParserKW_FOR)
	}
	{
		p.SetState(270)
		p.Simpleforbinding()
	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserCOMMA {
		{
			p.SetState(271)
			p.Match(XPath31ParserCOMMA)
		}
		{
			p.SetState(272)
			p.Simpleforbinding()
		}


		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ISimpleforbindingContext is an interface to support dynamic dispatch.
type ISimpleforbindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleforbindingContext differentiates from other interfaces.
	IsSimpleforbindingContext()
}

type SimpleforbindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleforbindingContext() *SimpleforbindingContext {
	var p = new(SimpleforbindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_simpleforbinding
	return p
}

func (*SimpleforbindingContext) IsSimpleforbindingContext() {}

func NewSimpleforbindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleforbindingContext {
	var p = new(SimpleforbindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_simpleforbinding

	return p
}

func (s *SimpleforbindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleforbindingContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserDOLLAR, 0)
}

func (s *SimpleforbindingContext) Varname() IVarnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarnameContext)
}

func (s *SimpleforbindingContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IN, 0)
}

func (s *SimpleforbindingContext) Exprsingle() IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *SimpleforbindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleforbindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleforbindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSimpleforbinding(s)
	}
}

func (s *SimpleforbindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSimpleforbinding(s)
	}
}




func (p *XPath31Parser) Simpleforbinding() (localctx ISimpleforbindingContext) {
	localctx = NewSimpleforbindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, XPath31ParserRULE_simpleforbinding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(278)
		p.Match(XPath31ParserDOLLAR)
	}
	{
		p.SetState(279)
		p.Varname()
	}
	{
		p.SetState(280)
		p.Match(XPath31ParserKW_IN)
	}
	{
		p.SetState(281)
		p.Exprsingle()
	}



	return localctx
}


// ILetexprContext is an interface to support dynamic dispatch.
type ILetexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLetexprContext differentiates from other interfaces.
	IsLetexprContext()
}

type LetexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetexprContext() *LetexprContext {
	var p = new(LetexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_letexpr
	return p
}

func (*LetexprContext) IsLetexprContext() {}

func NewLetexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetexprContext {
	var p = new(LetexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_letexpr

	return p
}

func (s *LetexprContext) GetParser() antlr.Parser { return s.parser }

func (s *LetexprContext) Simpleletclause() ISimpleletclauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleletclauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleletclauseContext)
}

func (s *LetexprContext) KW_RETURN() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_RETURN, 0)
}

func (s *LetexprContext) Exprsingle() IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *LetexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LetexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterLetexpr(s)
	}
}

func (s *LetexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitLetexpr(s)
	}
}




func (p *XPath31Parser) Letexpr() (localctx ILetexprContext) {
	localctx = NewLetexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, XPath31ParserRULE_letexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Simpleletclause()
	}
	{
		p.SetState(284)
		p.Match(XPath31ParserKW_RETURN)
	}
	{
		p.SetState(285)
		p.Exprsingle()
	}



	return localctx
}


// ISimpleletclauseContext is an interface to support dynamic dispatch.
type ISimpleletclauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleletclauseContext differentiates from other interfaces.
	IsSimpleletclauseContext()
}

type SimpleletclauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleletclauseContext() *SimpleletclauseContext {
	var p = new(SimpleletclauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_simpleletclause
	return p
}

func (*SimpleletclauseContext) IsSimpleletclauseContext() {}

func NewSimpleletclauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleletclauseContext {
	var p = new(SimpleletclauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_simpleletclause

	return p
}

func (s *SimpleletclauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleletclauseContext) KW_LET() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_LET, 0)
}

func (s *SimpleletclauseContext) AllSimpleletbinding() []ISimpleletbindingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimpleletbindingContext)(nil)).Elem())
	var tst = make([]ISimpleletbindingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimpleletbindingContext)
		}
	}

	return tst
}

func (s *SimpleletclauseContext) Simpleletbinding(i int) ISimpleletbindingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleletbindingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimpleletbindingContext)
}

func (s *SimpleletclauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *SimpleletclauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *SimpleletclauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleletclauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleletclauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSimpleletclause(s)
	}
}

func (s *SimpleletclauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSimpleletclause(s)
	}
}




func (p *XPath31Parser) Simpleletclause() (localctx ISimpleletclauseContext) {
	localctx = NewSimpleletclauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, XPath31ParserRULE_simpleletclause)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(XPath31ParserKW_LET)
	}
	{
		p.SetState(288)
		p.Simpleletbinding()
	}
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserCOMMA {
		{
			p.SetState(289)
			p.Match(XPath31ParserCOMMA)
		}
		{
			p.SetState(290)
			p.Simpleletbinding()
		}


		p.SetState(295)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// ISimpleletbindingContext is an interface to support dynamic dispatch.
type ISimpleletbindingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleletbindingContext differentiates from other interfaces.
	IsSimpleletbindingContext()
}

type SimpleletbindingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleletbindingContext() *SimpleletbindingContext {
	var p = new(SimpleletbindingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_simpleletbinding
	return p
}

func (*SimpleletbindingContext) IsSimpleletbindingContext() {}

func NewSimpleletbindingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleletbindingContext {
	var p = new(SimpleletbindingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_simpleletbinding

	return p
}

func (s *SimpleletbindingContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleletbindingContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserDOLLAR, 0)
}

func (s *SimpleletbindingContext) Varname() IVarnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarnameContext)
}

func (s *SimpleletbindingContext) CEQ() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCEQ, 0)
}

func (s *SimpleletbindingContext) Exprsingle() IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *SimpleletbindingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleletbindingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpleletbindingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSimpleletbinding(s)
	}
}

func (s *SimpleletbindingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSimpleletbinding(s)
	}
}




func (p *XPath31Parser) Simpleletbinding() (localctx ISimpleletbindingContext) {
	localctx = NewSimpleletbindingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, XPath31ParserRULE_simpleletbinding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(296)
		p.Match(XPath31ParserDOLLAR)
	}
	{
		p.SetState(297)
		p.Varname()
	}
	{
		p.SetState(298)
		p.Match(XPath31ParserCEQ)
	}
	{
		p.SetState(299)
		p.Exprsingle()
	}



	return localctx
}


// IQuantifiedexprContext is an interface to support dynamic dispatch.
type IQuantifiedexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuantifiedexprContext differentiates from other interfaces.
	IsQuantifiedexprContext()
}

type QuantifiedexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantifiedexprContext() *QuantifiedexprContext {
	var p = new(QuantifiedexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_quantifiedexpr
	return p
}

func (*QuantifiedexprContext) IsQuantifiedexprContext() {}

func NewQuantifiedexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifiedexprContext {
	var p = new(QuantifiedexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_quantifiedexpr

	return p
}

func (s *QuantifiedexprContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifiedexprContext) AllDOLLAR() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserDOLLAR)
}

func (s *QuantifiedexprContext) DOLLAR(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserDOLLAR, i)
}

func (s *QuantifiedexprContext) AllVarname() []IVarnameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVarnameContext)(nil)).Elem())
	var tst = make([]IVarnameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVarnameContext)
		}
	}

	return tst
}

func (s *QuantifiedexprContext) Varname(i int) IVarnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarnameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVarnameContext)
}

func (s *QuantifiedexprContext) AllKW_IN() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_IN)
}

func (s *QuantifiedexprContext) KW_IN(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IN, i)
}

func (s *QuantifiedexprContext) AllExprsingle() []IExprsingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprsingleContext)(nil)).Elem())
	var tst = make([]IExprsingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprsingleContext)
		}
	}

	return tst
}

func (s *QuantifiedexprContext) Exprsingle(i int) IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *QuantifiedexprContext) KW_SATISFIES() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SATISFIES, 0)
}

func (s *QuantifiedexprContext) KW_SOME() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SOME, 0)
}

func (s *QuantifiedexprContext) KW_EVERY() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EVERY, 0)
}

func (s *QuantifiedexprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *QuantifiedexprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *QuantifiedexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifiedexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QuantifiedexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterQuantifiedexpr(s)
	}
}

func (s *QuantifiedexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitQuantifiedexpr(s)
	}
}




func (p *XPath31Parser) Quantifiedexpr() (localctx IQuantifiedexprContext) {
	localctx = NewQuantifiedexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, XPath31ParserRULE_quantifiedexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(301)
		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath31ParserKW_EVERY || _la == XPath31ParserKW_SOME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(302)
		p.Match(XPath31ParserDOLLAR)
	}
	{
		p.SetState(303)
		p.Varname()
	}
	{
		p.SetState(304)
		p.Match(XPath31ParserKW_IN)
	}
	{
		p.SetState(305)
		p.Exprsingle()
	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserCOMMA {
		{
			p.SetState(306)
			p.Match(XPath31ParserCOMMA)
		}
		{
			p.SetState(307)
			p.Match(XPath31ParserDOLLAR)
		}
		{
			p.SetState(308)
			p.Varname()
		}
		{
			p.SetState(309)
			p.Match(XPath31ParserKW_IN)
		}
		{
			p.SetState(310)
			p.Exprsingle()
		}


		p.SetState(316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(317)
		p.Match(XPath31ParserKW_SATISFIES)
	}
	{
		p.SetState(318)
		p.Exprsingle()
	}



	return localctx
}


// IIfexprContext is an interface to support dynamic dispatch.
type IIfexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfexprContext differentiates from other interfaces.
	IsIfexprContext()
}

type IfexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfexprContext() *IfexprContext {
	var p = new(IfexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_ifexpr
	return p
}

func (*IfexprContext) IsIfexprContext() {}

func NewIfexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfexprContext {
	var p = new(IfexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_ifexpr

	return p
}

func (s *IfexprContext) GetParser() antlr.Parser { return s.parser }

func (s *IfexprContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IF, 0)
}

func (s *IfexprContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *IfexprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfexprContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *IfexprContext) KW_THEN() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_THEN, 0)
}

func (s *IfexprContext) AllExprsingle() []IExprsingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprsingleContext)(nil)).Elem())
	var tst = make([]IExprsingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprsingleContext)
		}
	}

	return tst
}

func (s *IfexprContext) Exprsingle(i int) IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *IfexprContext) KW_ELSE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ELSE, 0)
}

func (s *IfexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IfexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterIfexpr(s)
	}
}

func (s *IfexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitIfexpr(s)
	}
}




func (p *XPath31Parser) Ifexpr() (localctx IIfexprContext) {
	localctx = NewIfexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, XPath31ParserRULE_ifexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(320)
		p.Match(XPath31ParserKW_IF)
	}
	{
		p.SetState(321)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(322)
		p.Expr()
	}
	{
		p.SetState(323)
		p.Match(XPath31ParserCP)
	}
	{
		p.SetState(324)
		p.Match(XPath31ParserKW_THEN)
	}
	{
		p.SetState(325)
		p.Exprsingle()
	}
	{
		p.SetState(326)
		p.Match(XPath31ParserKW_ELSE)
	}
	{
		p.SetState(327)
		p.Exprsingle()
	}



	return localctx
}


// IOrexprContext is an interface to support dynamic dispatch.
type IOrexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrexprContext differentiates from other interfaces.
	IsOrexprContext()
}

type OrexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrexprContext() *OrexprContext {
	var p = new(OrexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_orexpr
	return p
}

func (*OrexprContext) IsOrexprContext() {}

func NewOrexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrexprContext {
	var p = new(OrexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_orexpr

	return p
}

func (s *OrexprContext) GetParser() antlr.Parser { return s.parser }

func (s *OrexprContext) AllAndexpr() []IAndexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAndexprContext)(nil)).Elem())
	var tst = make([]IAndexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAndexprContext)
		}
	}

	return tst
}

func (s *OrexprContext) Andexpr(i int) IAndexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAndexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAndexprContext)
}

func (s *OrexprContext) AllKW_OR() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_OR)
}

func (s *OrexprContext) KW_OR(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_OR, i)
}

func (s *OrexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OrexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterOrexpr(s)
	}
}

func (s *OrexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitOrexpr(s)
	}
}




func (p *XPath31Parser) Orexpr() (localctx IOrexprContext) {
	localctx = NewOrexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, XPath31ParserRULE_orexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(329)
		p.Andexpr()
	}
	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserKW_OR {
		{
			p.SetState(330)
			p.Match(XPath31ParserKW_OR)
		}
		{
			p.SetState(331)
			p.Andexpr()
		}


		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IAndexprContext is an interface to support dynamic dispatch.
type IAndexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndexprContext differentiates from other interfaces.
	IsAndexprContext()
}

type AndexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndexprContext() *AndexprContext {
	var p = new(AndexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_andexpr
	return p
}

func (*AndexprContext) IsAndexprContext() {}

func NewAndexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndexprContext {
	var p = new(AndexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_andexpr

	return p
}

func (s *AndexprContext) GetParser() antlr.Parser { return s.parser }

func (s *AndexprContext) AllComparisonexpr() []IComparisonexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComparisonexprContext)(nil)).Elem())
	var tst = make([]IComparisonexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComparisonexprContext)
		}
	}

	return tst
}

func (s *AndexprContext) Comparisonexpr(i int) IComparisonexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComparisonexprContext)
}

func (s *AndexprContext) AllKW_AND() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_AND)
}

func (s *AndexprContext) KW_AND(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AND, i)
}

func (s *AndexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AndexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAndexpr(s)
	}
}

func (s *AndexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAndexpr(s)
	}
}




func (p *XPath31Parser) Andexpr() (localctx IAndexprContext) {
	localctx = NewAndexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, XPath31ParserRULE_andexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.Comparisonexpr()
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserKW_AND {
		{
			p.SetState(338)
			p.Match(XPath31ParserKW_AND)
		}
		{
			p.SetState(339)
			p.Comparisonexpr()
		}


		p.SetState(344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IComparisonexprContext is an interface to support dynamic dispatch.
type IComparisonexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonexprContext differentiates from other interfaces.
	IsComparisonexprContext()
}

type ComparisonexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonexprContext() *ComparisonexprContext {
	var p = new(ComparisonexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_comparisonexpr
	return p
}

func (*ComparisonexprContext) IsComparisonexprContext() {}

func NewComparisonexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonexprContext {
	var p = new(ComparisonexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_comparisonexpr

	return p
}

func (s *ComparisonexprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonexprContext) AllStringconcatexpr() []IStringconcatexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringconcatexprContext)(nil)).Elem())
	var tst = make([]IStringconcatexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringconcatexprContext)
		}
	}

	return tst
}

func (s *ComparisonexprContext) Stringconcatexpr(i int) IStringconcatexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringconcatexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringconcatexprContext)
}

func (s *ComparisonexprContext) Valuecomp() IValuecompContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuecompContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValuecompContext)
}

func (s *ComparisonexprContext) Generalcomp() IGeneralcompContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneralcompContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneralcompContext)
}

func (s *ComparisonexprContext) Nodecomp() INodecompContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodecompContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodecompContext)
}

func (s *ComparisonexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ComparisonexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterComparisonexpr(s)
	}
}

func (s *ComparisonexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitComparisonexpr(s)
	}
}




func (p *XPath31Parser) Comparisonexpr() (localctx IComparisonexprContext) {
	localctx = NewComparisonexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, XPath31ParserRULE_comparisonexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(345)
		p.Stringconcatexpr()
	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << XPath31ParserEQ) | (1 << XPath31ParserGE) | (1 << XPath31ParserGG) | (1 << XPath31ParserGT) | (1 << XPath31ParserLE) | (1 << XPath31ParserLL) | (1 << XPath31ParserLT) | (1 << XPath31ParserNE))) != 0) || ((((_la - 53)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 53))) & ((1 << (XPath31ParserKW_EQ - 53)) | (1 << (XPath31ParserKW_GE - 53)) | (1 << (XPath31ParserKW_GT - 53)) | (1 << (XPath31ParserKW_IS - 53)) | (1 << (XPath31ParserKW_LE - 53)) | (1 << (XPath31ParserKW_LT - 53)) | (1 << (XPath31ParserKW_NE - 53)))) != 0) {
		p.SetState(349)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case XPath31ParserKW_EQ, XPath31ParserKW_GE, XPath31ParserKW_GT, XPath31ParserKW_LE, XPath31ParserKW_LT, XPath31ParserKW_NE:
			{
				p.SetState(346)
				p.Valuecomp()
			}


		case XPath31ParserEQ, XPath31ParserGE, XPath31ParserGT, XPath31ParserLE, XPath31ParserLT, XPath31ParserNE:
			{
				p.SetState(347)
				p.Generalcomp()
			}


		case XPath31ParserGG, XPath31ParserLL, XPath31ParserKW_IS:
			{
				p.SetState(348)
				p.Nodecomp()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(351)
			p.Stringconcatexpr()
		}

	}



	return localctx
}


// IStringconcatexprContext is an interface to support dynamic dispatch.
type IStringconcatexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringconcatexprContext differentiates from other interfaces.
	IsStringconcatexprContext()
}

type StringconcatexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringconcatexprContext() *StringconcatexprContext {
	var p = new(StringconcatexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_stringconcatexpr
	return p
}

func (*StringconcatexprContext) IsStringconcatexprContext() {}

func NewStringconcatexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringconcatexprContext {
	var p = new(StringconcatexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_stringconcatexpr

	return p
}

func (s *StringconcatexprContext) GetParser() antlr.Parser { return s.parser }

func (s *StringconcatexprContext) AllRangeexpr() []IRangeexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRangeexprContext)(nil)).Elem())
	var tst = make([]IRangeexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRangeexprContext)
		}
	}

	return tst
}

func (s *StringconcatexprContext) Rangeexpr(i int) IRangeexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRangeexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRangeexprContext)
}

func (s *StringconcatexprContext) AllPP() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserPP)
}

func (s *StringconcatexprContext) PP(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserPP, i)
}

func (s *StringconcatexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringconcatexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StringconcatexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterStringconcatexpr(s)
	}
}

func (s *StringconcatexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitStringconcatexpr(s)
	}
}




func (p *XPath31Parser) Stringconcatexpr() (localctx IStringconcatexprContext) {
	localctx = NewStringconcatexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, XPath31ParserRULE_stringconcatexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Rangeexpr()
	}
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserPP {
		{
			p.SetState(356)
			p.Match(XPath31ParserPP)
		}
		{
			p.SetState(357)
			p.Rangeexpr()
		}


		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IRangeexprContext is an interface to support dynamic dispatch.
type IRangeexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRangeexprContext differentiates from other interfaces.
	IsRangeexprContext()
}

type RangeexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeexprContext() *RangeexprContext {
	var p = new(RangeexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_rangeexpr
	return p
}

func (*RangeexprContext) IsRangeexprContext() {}

func NewRangeexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeexprContext {
	var p = new(RangeexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_rangeexpr

	return p
}

func (s *RangeexprContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeexprContext) AllAdditiveexpr() []IAdditiveexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdditiveexprContext)(nil)).Elem())
	var tst = make([]IAdditiveexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdditiveexprContext)
		}
	}

	return tst
}

func (s *RangeexprContext) Additiveexpr(i int) IAdditiveexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdditiveexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdditiveexprContext)
}

func (s *RangeexprContext) KW_TO() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_TO, 0)
}

func (s *RangeexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RangeexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterRangeexpr(s)
	}
}

func (s *RangeexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitRangeexpr(s)
	}
}




func (p *XPath31Parser) Rangeexpr() (localctx IRangeexprContext) {
	localctx = NewRangeexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, XPath31ParserRULE_rangeexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(363)
		p.Additiveexpr()
	}
	p.SetState(366)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserKW_TO {
		{
			p.SetState(364)
			p.Match(XPath31ParserKW_TO)
		}
		{
			p.SetState(365)
			p.Additiveexpr()
		}

	}



	return localctx
}


// IAdditiveexprContext is an interface to support dynamic dispatch.
type IAdditiveexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdditiveexprContext differentiates from other interfaces.
	IsAdditiveexprContext()
}

type AdditiveexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveexprContext() *AdditiveexprContext {
	var p = new(AdditiveexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_additiveexpr
	return p
}

func (*AdditiveexprContext) IsAdditiveexprContext() {}

func NewAdditiveexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveexprContext {
	var p = new(AdditiveexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_additiveexpr

	return p
}

func (s *AdditiveexprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveexprContext) AllMultiplicativeexpr() []IMultiplicativeexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMultiplicativeexprContext)(nil)).Elem())
	var tst = make([]IMultiplicativeexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMultiplicativeexprContext)
		}
	}

	return tst
}

func (s *AdditiveexprContext) Multiplicativeexpr(i int) IMultiplicativeexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMultiplicativeexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeexprContext)
}

func (s *AdditiveexprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserPLUS)
}

func (s *AdditiveexprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserPLUS, i)
}

func (s *AdditiveexprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserMINUS)
}

func (s *AdditiveexprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserMINUS, i)
}

func (s *AdditiveexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AdditiveexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAdditiveexpr(s)
	}
}

func (s *AdditiveexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAdditiveexpr(s)
	}
}




func (p *XPath31Parser) Additiveexpr() (localctx IAdditiveexprContext) {
	localctx = NewAdditiveexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, XPath31ParserRULE_additiveexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Multiplicativeexpr()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserMINUS || _la == XPath31ParserPLUS {
		{
			p.SetState(369)
			_la = p.GetTokenStream().LA(1)

			if !(_la == XPath31ParserMINUS || _la == XPath31ParserPLUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(370)
			p.Multiplicativeexpr()
		}


		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IMultiplicativeexprContext is an interface to support dynamic dispatch.
type IMultiplicativeexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplicativeexprContext differentiates from other interfaces.
	IsMultiplicativeexprContext()
}

type MultiplicativeexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeexprContext() *MultiplicativeexprContext {
	var p = new(MultiplicativeexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_multiplicativeexpr
	return p
}

func (*MultiplicativeexprContext) IsMultiplicativeexprContext() {}

func NewMultiplicativeexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeexprContext {
	var p = new(MultiplicativeexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_multiplicativeexpr

	return p
}

func (s *MultiplicativeexprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeexprContext) AllUnionexpr() []IUnionexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionexprContext)(nil)).Elem())
	var tst = make([]IUnionexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionexprContext)
		}
	}

	return tst
}

func (s *MultiplicativeexprContext) Unionexpr(i int) IUnionexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionexprContext)
}

func (s *MultiplicativeexprContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserSTAR)
}

func (s *MultiplicativeexprContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, i)
}

func (s *MultiplicativeexprContext) AllKW_DIV() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_DIV)
}

func (s *MultiplicativeexprContext) KW_DIV(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DIV, i)
}

func (s *MultiplicativeexprContext) AllKW_IDIV() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_IDIV)
}

func (s *MultiplicativeexprContext) KW_IDIV(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IDIV, i)
}

func (s *MultiplicativeexprContext) AllKW_MOD() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_MOD)
}

func (s *MultiplicativeexprContext) KW_MOD(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_MOD, i)
}

func (s *MultiplicativeexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MultiplicativeexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterMultiplicativeexpr(s)
	}
}

func (s *MultiplicativeexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitMultiplicativeexpr(s)
	}
}




func (p *XPath31Parser) Multiplicativeexpr() (localctx IMultiplicativeexprContext) {
	localctx = NewMultiplicativeexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, XPath31ParserRULE_multiplicativeexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Unionexpr()
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for ((((_la - 35)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 35))) & ((1 << (XPath31ParserSTAR - 35)) | (1 << (XPath31ParserKW_DIV - 35)) | (1 << (XPath31ParserKW_IDIV - 35)))) != 0) || _la == XPath31ParserKW_MOD {
		{
			p.SetState(377)
			_la = p.GetTokenStream().LA(1)

			if !(((((_la - 35)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 35))) & ((1 << (XPath31ParserSTAR - 35)) | (1 << (XPath31ParserKW_DIV - 35)) | (1 << (XPath31ParserKW_IDIV - 35)))) != 0) || _la == XPath31ParserKW_MOD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(378)
			p.Unionexpr()
		}


		p.SetState(383)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IUnionexprContext is an interface to support dynamic dispatch.
type IUnionexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionexprContext differentiates from other interfaces.
	IsUnionexprContext()
}

type UnionexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionexprContext() *UnionexprContext {
	var p = new(UnionexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_unionexpr
	return p
}

func (*UnionexprContext) IsUnionexprContext() {}

func NewUnionexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionexprContext {
	var p = new(UnionexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_unionexpr

	return p
}

func (s *UnionexprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionexprContext) AllIntersectexceptexpr() []IIntersectexceptexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIntersectexceptexprContext)(nil)).Elem())
	var tst = make([]IIntersectexceptexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIntersectexceptexprContext)
		}
	}

	return tst
}

func (s *UnionexprContext) Intersectexceptexpr(i int) IIntersectexceptexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntersectexceptexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIntersectexceptexprContext)
}

func (s *UnionexprContext) AllKW_UNION() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_UNION)
}

func (s *UnionexprContext) KW_UNION(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_UNION, i)
}

func (s *UnionexprContext) AllP() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserP)
}

func (s *UnionexprContext) P(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserP, i)
}

func (s *UnionexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnionexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterUnionexpr(s)
	}
}

func (s *UnionexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitUnionexpr(s)
	}
}




func (p *XPath31Parser) Unionexpr() (localctx IUnionexprContext) {
	localctx = NewUnionexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, XPath31ParserRULE_unionexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Intersectexceptexpr()
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserP || _la == XPath31ParserKW_UNION {
		{
			p.SetState(385)
			_la = p.GetTokenStream().LA(1)

			if !(_la == XPath31ParserP || _la == XPath31ParserKW_UNION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(386)
			p.Intersectexceptexpr()
		}


		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IIntersectexceptexprContext is an interface to support dynamic dispatch.
type IIntersectexceptexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntersectexceptexprContext differentiates from other interfaces.
	IsIntersectexceptexprContext()
}

type IntersectexceptexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntersectexceptexprContext() *IntersectexceptexprContext {
	var p = new(IntersectexceptexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_intersectexceptexpr
	return p
}

func (*IntersectexceptexprContext) IsIntersectexceptexprContext() {}

func NewIntersectexceptexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntersectexceptexprContext {
	var p = new(IntersectexceptexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_intersectexceptexpr

	return p
}

func (s *IntersectexceptexprContext) GetParser() antlr.Parser { return s.parser }

func (s *IntersectexceptexprContext) AllInstanceofexpr() []IInstanceofexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInstanceofexprContext)(nil)).Elem())
	var tst = make([]IInstanceofexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInstanceofexprContext)
		}
	}

	return tst
}

func (s *IntersectexceptexprContext) Instanceofexpr(i int) IInstanceofexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInstanceofexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInstanceofexprContext)
}

func (s *IntersectexceptexprContext) AllKW_INTERSECT() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_INTERSECT)
}

func (s *IntersectexceptexprContext) KW_INTERSECT(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_INTERSECT, i)
}

func (s *IntersectexceptexprContext) AllKW_EXCEPT() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserKW_EXCEPT)
}

func (s *IntersectexceptexprContext) KW_EXCEPT(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EXCEPT, i)
}

func (s *IntersectexceptexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntersectexceptexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntersectexceptexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterIntersectexceptexpr(s)
	}
}

func (s *IntersectexceptexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitIntersectexceptexpr(s)
	}
}




func (p *XPath31Parser) Intersectexceptexpr() (localctx IIntersectexceptexprContext) {
	localctx = NewIntersectexceptexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, XPath31ParserRULE_intersectexceptexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Instanceofexpr()
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserKW_EXCEPT || _la == XPath31ParserKW_INTERSECT {
		{
			p.SetState(393)
			_la = p.GetTokenStream().LA(1)

			if !(_la == XPath31ParserKW_EXCEPT || _la == XPath31ParserKW_INTERSECT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(394)
			p.Instanceofexpr()
		}


		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IInstanceofexprContext is an interface to support dynamic dispatch.
type IInstanceofexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstanceofexprContext differentiates from other interfaces.
	IsInstanceofexprContext()
}

type InstanceofexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceofexprContext() *InstanceofexprContext {
	var p = new(InstanceofexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_instanceofexpr
	return p
}

func (*InstanceofexprContext) IsInstanceofexprContext() {}

func NewInstanceofexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceofexprContext {
	var p = new(InstanceofexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_instanceofexpr

	return p
}

func (s *InstanceofexprContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceofexprContext) Treatexpr() ITreatexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITreatexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITreatexprContext)
}

func (s *InstanceofexprContext) KW_INSTANCE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_INSTANCE, 0)
}

func (s *InstanceofexprContext) KW_OF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_OF, 0)
}

func (s *InstanceofexprContext) Sequencetype() ISequencetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequencetypeContext)
}

func (s *InstanceofexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceofexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InstanceofexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterInstanceofexpr(s)
	}
}

func (s *InstanceofexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitInstanceofexpr(s)
	}
}




func (p *XPath31Parser) Instanceofexpr() (localctx IInstanceofexprContext) {
	localctx = NewInstanceofexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, XPath31ParserRULE_instanceofexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(400)
		p.Treatexpr()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserKW_INSTANCE {
		{
			p.SetState(401)
			p.Match(XPath31ParserKW_INSTANCE)
		}
		{
			p.SetState(402)
			p.Match(XPath31ParserKW_OF)
		}
		{
			p.SetState(403)
			p.Sequencetype()
		}

	}



	return localctx
}


// ITreatexprContext is an interface to support dynamic dispatch.
type ITreatexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTreatexprContext differentiates from other interfaces.
	IsTreatexprContext()
}

type TreatexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTreatexprContext() *TreatexprContext {
	var p = new(TreatexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_treatexpr
	return p
}

func (*TreatexprContext) IsTreatexprContext() {}

func NewTreatexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TreatexprContext {
	var p = new(TreatexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_treatexpr

	return p
}

func (s *TreatexprContext) GetParser() antlr.Parser { return s.parser }

func (s *TreatexprContext) Castableexpr() ICastableexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastableexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastableexprContext)
}

func (s *TreatexprContext) KW_TREAT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_TREAT, 0)
}

func (s *TreatexprContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AS, 0)
}

func (s *TreatexprContext) Sequencetype() ISequencetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequencetypeContext)
}

func (s *TreatexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TreatexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TreatexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterTreatexpr(s)
	}
}

func (s *TreatexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitTreatexpr(s)
	}
}




func (p *XPath31Parser) Treatexpr() (localctx ITreatexprContext) {
	localctx = NewTreatexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, XPath31ParserRULE_treatexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)
		p.Castableexpr()
	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserKW_TREAT {
		{
			p.SetState(407)
			p.Match(XPath31ParserKW_TREAT)
		}
		{
			p.SetState(408)
			p.Match(XPath31ParserKW_AS)
		}
		{
			p.SetState(409)
			p.Sequencetype()
		}

	}



	return localctx
}


// ICastableexprContext is an interface to support dynamic dispatch.
type ICastableexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastableexprContext differentiates from other interfaces.
	IsCastableexprContext()
}

type CastableexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastableexprContext() *CastableexprContext {
	var p = new(CastableexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_castableexpr
	return p
}

func (*CastableexprContext) IsCastableexprContext() {}

func NewCastableexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastableexprContext {
	var p = new(CastableexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_castableexpr

	return p
}

func (s *CastableexprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastableexprContext) Castexpr() ICastexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastexprContext)
}

func (s *CastableexprContext) KW_CASTABLE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_CASTABLE, 0)
}

func (s *CastableexprContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AS, 0)
}

func (s *CastableexprContext) Singletype() ISingletypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingletypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingletypeContext)
}

func (s *CastableexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastableexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CastableexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterCastableexpr(s)
	}
}

func (s *CastableexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitCastableexpr(s)
	}
}




func (p *XPath31Parser) Castableexpr() (localctx ICastableexprContext) {
	localctx = NewCastableexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, XPath31ParserRULE_castableexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(412)
		p.Castexpr()
	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserKW_CASTABLE {
		{
			p.SetState(413)
			p.Match(XPath31ParserKW_CASTABLE)
		}
		{
			p.SetState(414)
			p.Match(XPath31ParserKW_AS)
		}
		{
			p.SetState(415)
			p.Singletype()
		}

	}



	return localctx
}


// ICastexprContext is an interface to support dynamic dispatch.
type ICastexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastexprContext differentiates from other interfaces.
	IsCastexprContext()
}

type CastexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastexprContext() *CastexprContext {
	var p = new(CastexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_castexpr
	return p
}

func (*CastexprContext) IsCastexprContext() {}

func NewCastexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastexprContext {
	var p = new(CastexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_castexpr

	return p
}

func (s *CastexprContext) GetParser() antlr.Parser { return s.parser }

func (s *CastexprContext) Arrowexpr() IArrowexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrowexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrowexprContext)
}

func (s *CastexprContext) KW_CAST() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_CAST, 0)
}

func (s *CastexprContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AS, 0)
}

func (s *CastexprContext) Singletype() ISingletypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingletypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingletypeContext)
}

func (s *CastexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CastexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterCastexpr(s)
	}
}

func (s *CastexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitCastexpr(s)
	}
}




func (p *XPath31Parser) Castexpr() (localctx ICastexprContext) {
	localctx = NewCastexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, XPath31ParserRULE_castexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(418)
		p.Arrowexpr()
	}
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserKW_CAST {
		{
			p.SetState(419)
			p.Match(XPath31ParserKW_CAST)
		}
		{
			p.SetState(420)
			p.Match(XPath31ParserKW_AS)
		}
		{
			p.SetState(421)
			p.Singletype()
		}

	}



	return localctx
}


// IArrowexprContext is an interface to support dynamic dispatch.
type IArrowexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowexprContext differentiates from other interfaces.
	IsArrowexprContext()
}

type ArrowexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowexprContext() *ArrowexprContext {
	var p = new(ArrowexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_arrowexpr
	return p
}

func (*ArrowexprContext) IsArrowexprContext() {}

func NewArrowexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowexprContext {
	var p = new(ArrowexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_arrowexpr

	return p
}

func (s *ArrowexprContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowexprContext) Unaryexpr() IUnaryexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryexprContext)
}

func (s *ArrowexprContext) AllEG() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserEG)
}

func (s *ArrowexprContext) EG(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserEG, i)
}

func (s *ArrowexprContext) AllArrowfunctionspecifier() []IArrowfunctionspecifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrowfunctionspecifierContext)(nil)).Elem())
	var tst = make([]IArrowfunctionspecifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrowfunctionspecifierContext)
		}
	}

	return tst
}

func (s *ArrowexprContext) Arrowfunctionspecifier(i int) IArrowfunctionspecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrowfunctionspecifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrowfunctionspecifierContext)
}

func (s *ArrowexprContext) AllArgumentlist() []IArgumentlistContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentlistContext)(nil)).Elem())
	var tst = make([]IArgumentlistContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentlistContext)
		}
	}

	return tst
}

func (s *ArrowexprContext) Argumentlist(i int) IArgumentlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentlistContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentlistContext)
}

func (s *ArrowexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrowexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterArrowexpr(s)
	}
}

func (s *ArrowexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitArrowexpr(s)
	}
}




func (p *XPath31Parser) Arrowexpr() (localctx IArrowexprContext) {
	localctx = NewArrowexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, XPath31ParserRULE_arrowexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Unaryexpr()
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserEG {
		{
			p.SetState(425)
			p.Match(XPath31ParserEG)
		}
		{
			p.SetState(426)
			p.Arrowfunctionspecifier()
		}
		{
			p.SetState(427)
			p.Argumentlist()
		}


		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IUnaryexprContext is an interface to support dynamic dispatch.
type IUnaryexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryexprContext differentiates from other interfaces.
	IsUnaryexprContext()
}

type UnaryexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryexprContext() *UnaryexprContext {
	var p = new(UnaryexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_unaryexpr
	return p
}

func (*UnaryexprContext) IsUnaryexprContext() {}

func NewUnaryexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryexprContext {
	var p = new(UnaryexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_unaryexpr

	return p
}

func (s *UnaryexprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryexprContext) Valueexpr() IValueexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueexprContext)
}

func (s *UnaryexprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserMINUS)
}

func (s *UnaryexprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserMINUS, i)
}

func (s *UnaryexprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserPLUS)
}

func (s *UnaryexprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserPLUS, i)
}

func (s *UnaryexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnaryexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterUnaryexpr(s)
	}
}

func (s *UnaryexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitUnaryexpr(s)
	}
}




func (p *XPath31Parser) Unaryexpr() (localctx IUnaryexprContext) {
	localctx = NewUnaryexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, XPath31ParserRULE_unaryexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(434)
				_la = p.GetTokenStream().LA(1)

				if !(_la == XPath31ParserMINUS || _la == XPath31ParserPLUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}


		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())
	}
	{
		p.SetState(440)
		p.Valueexpr()
	}



	return localctx
}


// IValueexprContext is an interface to support dynamic dispatch.
type IValueexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueexprContext differentiates from other interfaces.
	IsValueexprContext()
}

type ValueexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueexprContext() *ValueexprContext {
	var p = new(ValueexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_valueexpr
	return p
}

func (*ValueexprContext) IsValueexprContext() {}

func NewValueexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueexprContext {
	var p = new(ValueexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_valueexpr

	return p
}

func (s *ValueexprContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueexprContext) Simplemapexpr() ISimplemapexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimplemapexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimplemapexprContext)
}

func (s *ValueexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValueexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterValueexpr(s)
	}
}

func (s *ValueexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitValueexpr(s)
	}
}




func (p *XPath31Parser) Valueexpr() (localctx IValueexprContext) {
	localctx = NewValueexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, XPath31ParserRULE_valueexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(442)
		p.Simplemapexpr()
	}



	return localctx
}


// IGeneralcompContext is an interface to support dynamic dispatch.
type IGeneralcompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralcompContext differentiates from other interfaces.
	IsGeneralcompContext()
}

type GeneralcompContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralcompContext() *GeneralcompContext {
	var p = new(GeneralcompContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_generalcomp
	return p
}

func (*GeneralcompContext) IsGeneralcompContext() {}

func NewGeneralcompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralcompContext {
	var p = new(GeneralcompContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_generalcomp

	return p
}

func (s *GeneralcompContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralcompContext) EQ() antlr.TerminalNode {
	return s.GetToken(XPath31ParserEQ, 0)
}

func (s *GeneralcompContext) NE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserNE, 0)
}

func (s *GeneralcompContext) LT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserLT, 0)
}

func (s *GeneralcompContext) LE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserLE, 0)
}

func (s *GeneralcompContext) GT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserGT, 0)
}

func (s *GeneralcompContext) GE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserGE, 0)
}

func (s *GeneralcompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralcompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *GeneralcompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterGeneralcomp(s)
	}
}

func (s *GeneralcompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitGeneralcomp(s)
	}
}




func (p *XPath31Parser) Generalcomp() (localctx IGeneralcompContext) {
	localctx = NewGeneralcompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, XPath31ParserRULE_generalcomp)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		_la = p.GetTokenStream().LA(1)

		if !((((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << XPath31ParserEQ) | (1 << XPath31ParserGE) | (1 << XPath31ParserGT) | (1 << XPath31ParserLE) | (1 << XPath31ParserLT) | (1 << XPath31ParserNE))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IValuecompContext is an interface to support dynamic dispatch.
type IValuecompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuecompContext differentiates from other interfaces.
	IsValuecompContext()
}

type ValuecompContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuecompContext() *ValuecompContext {
	var p = new(ValuecompContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_valuecomp
	return p
}

func (*ValuecompContext) IsValuecompContext() {}

func NewValuecompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuecompContext {
	var p = new(ValuecompContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_valuecomp

	return p
}

func (s *ValuecompContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuecompContext) KW_EQ() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EQ, 0)
}

func (s *ValuecompContext) KW_NE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NE, 0)
}

func (s *ValuecompContext) KW_LT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_LT, 0)
}

func (s *ValuecompContext) KW_LE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_LE, 0)
}

func (s *ValuecompContext) KW_GT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_GT, 0)
}

func (s *ValuecompContext) KW_GE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_GE, 0)
}

func (s *ValuecompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuecompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValuecompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterValuecomp(s)
	}
}

func (s *ValuecompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitValuecomp(s)
	}
}




func (p *XPath31Parser) Valuecomp() (localctx IValuecompContext) {
	localctx = NewValuecompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, XPath31ParserRULE_valuecomp)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(446)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 53)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 53))) & ((1 << (XPath31ParserKW_EQ - 53)) | (1 << (XPath31ParserKW_GE - 53)) | (1 << (XPath31ParserKW_GT - 53)) | (1 << (XPath31ParserKW_LE - 53)) | (1 << (XPath31ParserKW_LT - 53)) | (1 << (XPath31ParserKW_NE - 53)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// INodecompContext is an interface to support dynamic dispatch.
type INodecompContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodecompContext differentiates from other interfaces.
	IsNodecompContext()
}

type NodecompContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodecompContext() *NodecompContext {
	var p = new(NodecompContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_nodecomp
	return p
}

func (*NodecompContext) IsNodecompContext() {}

func NewNodecompContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodecompContext {
	var p = new(NodecompContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_nodecomp

	return p
}

func (s *NodecompContext) GetParser() antlr.Parser { return s.parser }

func (s *NodecompContext) KW_IS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IS, 0)
}

func (s *NodecompContext) LL() antlr.TerminalNode {
	return s.GetToken(XPath31ParserLL, 0)
}

func (s *NodecompContext) GG() antlr.TerminalNode {
	return s.GetToken(XPath31ParserGG, 0)
}

func (s *NodecompContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodecompContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NodecompContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterNodecomp(s)
	}
}

func (s *NodecompContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitNodecomp(s)
	}
}




func (p *XPath31Parser) Nodecomp() (localctx INodecompContext) {
	localctx = NewNodecompContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, XPath31ParserRULE_nodecomp)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(448)
		_la = p.GetTokenStream().LA(1)

		if !(_la == XPath31ParserGG || _la == XPath31ParserLL || _la == XPath31ParserKW_IS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// ISimplemapexprContext is an interface to support dynamic dispatch.
type ISimplemapexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimplemapexprContext differentiates from other interfaces.
	IsSimplemapexprContext()
}

type SimplemapexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplemapexprContext() *SimplemapexprContext {
	var p = new(SimplemapexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_simplemapexpr
	return p
}

func (*SimplemapexprContext) IsSimplemapexprContext() {}

func NewSimplemapexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplemapexprContext {
	var p = new(SimplemapexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_simplemapexpr

	return p
}

func (s *SimplemapexprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplemapexprContext) AllPathexpr() []IPathexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPathexprContext)(nil)).Elem())
	var tst = make([]IPathexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPathexprContext)
		}
	}

	return tst
}

func (s *SimplemapexprContext) Pathexpr(i int) IPathexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPathexprContext)
}

func (s *SimplemapexprContext) AllBANG() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserBANG)
}

func (s *SimplemapexprContext) BANG(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserBANG, i)
}

func (s *SimplemapexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplemapexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimplemapexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSimplemapexpr(s)
	}
}

func (s *SimplemapexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSimplemapexpr(s)
	}
}




func (p *XPath31Parser) Simplemapexpr() (localctx ISimplemapexprContext) {
	localctx = NewSimplemapexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, XPath31ParserRULE_simplemapexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(450)
		p.Pathexpr()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserBANG {
		{
			p.SetState(451)
			p.Match(XPath31ParserBANG)
		}
		{
			p.SetState(452)
			p.Pathexpr()
		}


		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IPathexprContext is an interface to support dynamic dispatch.
type IPathexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPathexprContext differentiates from other interfaces.
	IsPathexprContext()
}

type PathexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPathexprContext() *PathexprContext {
	var p = new(PathexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_pathexpr
	return p
}

func (*PathexprContext) IsPathexprContext() {}

func NewPathexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathexprContext {
	var p = new(PathexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_pathexpr

	return p
}

func (s *PathexprContext) GetParser() antlr.Parser { return s.parser }

func (s *PathexprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSLASH, 0)
}

func (s *PathexprContext) Relativepathexpr() IRelativepathexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelativepathexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelativepathexprContext)
}

func (s *PathexprContext) SS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSS, 0)
}

func (s *PathexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PathexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterPathexpr(s)
	}
}

func (s *PathexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitPathexpr(s)
	}
}




func (p *XPath31Parser) Pathexpr() (localctx IPathexprContext) {
	localctx = NewPathexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, XPath31ParserRULE_pathexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(458)
			p.Match(XPath31ParserSLASH)
		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(459)
				p.Relativepathexpr()
			}


		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(462)
			p.Match(XPath31ParserSS)
		}
		{
			p.SetState(463)
			p.Relativepathexpr()
		}



	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(464)
			p.Relativepathexpr()
		}

	}


	return localctx
}


// IRelativepathexprContext is an interface to support dynamic dispatch.
type IRelativepathexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelativepathexprContext differentiates from other interfaces.
	IsRelativepathexprContext()
}

type RelativepathexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativepathexprContext() *RelativepathexprContext {
	var p = new(RelativepathexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_relativepathexpr
	return p
}

func (*RelativepathexprContext) IsRelativepathexprContext() {}

func NewRelativepathexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativepathexprContext {
	var p = new(RelativepathexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_relativepathexpr

	return p
}

func (s *RelativepathexprContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativepathexprContext) AllStepexpr() []IStepexprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStepexprContext)(nil)).Elem())
	var tst = make([]IStepexprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStepexprContext)
		}
	}

	return tst
}

func (s *RelativepathexprContext) Stepexpr(i int) IStepexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStepexprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStepexprContext)
}

func (s *RelativepathexprContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserSLASH)
}

func (s *RelativepathexprContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserSLASH, i)
}

func (s *RelativepathexprContext) AllSS() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserSS)
}

func (s *RelativepathexprContext) SS(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserSS, i)
}

func (s *RelativepathexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativepathexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RelativepathexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterRelativepathexpr(s)
	}
}

func (s *RelativepathexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitRelativepathexpr(s)
	}
}




func (p *XPath31Parser) Relativepathexpr() (localctx IRelativepathexprContext) {
	localctx = NewRelativepathexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, XPath31ParserRULE_relativepathexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Stepexpr()
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserSLASH || _la == XPath31ParserSS {
		{
			p.SetState(468)
			_la = p.GetTokenStream().LA(1)

			if !(_la == XPath31ParserSLASH || _la == XPath31ParserSS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(469)
			p.Stepexpr()
		}


		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IStepexprContext is an interface to support dynamic dispatch.
type IStepexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStepexprContext differentiates from other interfaces.
	IsStepexprContext()
}

type StepexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStepexprContext() *StepexprContext {
	var p = new(StepexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_stepexpr
	return p
}

func (*StepexprContext) IsStepexprContext() {}

func NewStepexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepexprContext {
	var p = new(StepexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_stepexpr

	return p
}

func (s *StepexprContext) GetParser() antlr.Parser { return s.parser }

func (s *StepexprContext) Postfixexpr() IPostfixexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixexprContext)
}

func (s *StepexprContext) Axisstep() IAxisstepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAxisstepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAxisstepContext)
}

func (s *StepexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StepexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterStepexpr(s)
	}
}

func (s *StepexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitStepexpr(s)
	}
}




func (p *XPath31Parser) Stepexpr() (localctx IStepexprContext) {
	localctx = NewStepexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, XPath31ParserRULE_stepexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(475)
			p.Postfixexpr()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(476)
			p.Axisstep()
		}

	}


	return localctx
}


// IAxisstepContext is an interface to support dynamic dispatch.
type IAxisstepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAxisstepContext differentiates from other interfaces.
	IsAxisstepContext()
}

type AxisstepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAxisstepContext() *AxisstepContext {
	var p = new(AxisstepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_axisstep
	return p
}

func (*AxisstepContext) IsAxisstepContext() {}

func NewAxisstepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AxisstepContext {
	var p = new(AxisstepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_axisstep

	return p
}

func (s *AxisstepContext) GetParser() antlr.Parser { return s.parser }

func (s *AxisstepContext) Predicatelist() IPredicatelistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicatelistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicatelistContext)
}

func (s *AxisstepContext) Reversestep() IReversestepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReversestepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReversestepContext)
}

func (s *AxisstepContext) Forwardstep() IForwardstepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForwardstepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForwardstepContext)
}

func (s *AxisstepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AxisstepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AxisstepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAxisstep(s)
	}
}

func (s *AxisstepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAxisstep(s)
	}
}




func (p *XPath31Parser) Axisstep() (localctx IAxisstepContext) {
	localctx = NewAxisstepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, XPath31ParserRULE_axisstep)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(479)
			p.Reversestep()
		}


	case 2:
		{
			p.SetState(480)
			p.Forwardstep()
		}

	}
	{
		p.SetState(483)
		p.Predicatelist()
	}



	return localctx
}


// IForwardstepContext is an interface to support dynamic dispatch.
type IForwardstepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForwardstepContext differentiates from other interfaces.
	IsForwardstepContext()
}

type ForwardstepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardstepContext() *ForwardstepContext {
	var p = new(ForwardstepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_forwardstep
	return p
}

func (*ForwardstepContext) IsForwardstepContext() {}

func NewForwardstepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardstepContext {
	var p = new(ForwardstepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_forwardstep

	return p
}

func (s *ForwardstepContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardstepContext) Forwardaxis() IForwardaxisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForwardaxisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForwardaxisContext)
}

func (s *ForwardstepContext) Nodetest() INodetestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodetestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodetestContext)
}

func (s *ForwardstepContext) Abbrevforwardstep() IAbbrevforwardstepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbbrevforwardstepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbbrevforwardstepContext)
}

func (s *ForwardstepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardstepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForwardstepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterForwardstep(s)
	}
}

func (s *ForwardstepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitForwardstep(s)
	}
}




func (p *XPath31Parser) Forwardstep() (localctx IForwardstepContext) {
	localctx = NewForwardstepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, XPath31ParserRULE_forwardstep)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(485)
			p.Forwardaxis()
		}
		{
			p.SetState(486)
			p.Nodetest()
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(488)
			p.Abbrevforwardstep()
		}

	}


	return localctx
}


// IForwardaxisContext is an interface to support dynamic dispatch.
type IForwardaxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForwardaxisContext differentiates from other interfaces.
	IsForwardaxisContext()
}

type ForwardaxisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForwardaxisContext() *ForwardaxisContext {
	var p = new(ForwardaxisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_forwardaxis
	return p
}

func (*ForwardaxisContext) IsForwardaxisContext() {}

func NewForwardaxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForwardaxisContext {
	var p = new(ForwardaxisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_forwardaxis

	return p
}

func (s *ForwardaxisContext) GetParser() antlr.Parser { return s.parser }

func (s *ForwardaxisContext) KW_CHILD() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_CHILD, 0)
}

func (s *ForwardaxisContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOLONCOLON, 0)
}

func (s *ForwardaxisContext) KW_DESCENDANT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DESCENDANT, 0)
}

func (s *ForwardaxisContext) KW_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ATTRIBUTE, 0)
}

func (s *ForwardaxisContext) KW_SELF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SELF, 0)
}

func (s *ForwardaxisContext) KW_DESCENDANT_OR_SELF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DESCENDANT_OR_SELF, 0)
}

func (s *ForwardaxisContext) KW_FOLLOWING_SIBLING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FOLLOWING_SIBLING, 0)
}

func (s *ForwardaxisContext) KW_FOLLOWING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FOLLOWING, 0)
}

func (s *ForwardaxisContext) KW_NAMESPACE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NAMESPACE, 0)
}

func (s *ForwardaxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForwardaxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ForwardaxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterForwardaxis(s)
	}
}

func (s *ForwardaxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitForwardaxis(s)
	}
}




func (p *XPath31Parser) Forwardaxis() (localctx IForwardaxisContext) {
	localctx = NewForwardaxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, XPath31ParserRULE_forwardaxis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(507)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_CHILD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(491)
			p.Match(XPath31ParserKW_CHILD)
		}
		{
			p.SetState(492)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_DESCENDANT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(493)
			p.Match(XPath31ParserKW_DESCENDANT)
		}
		{
			p.SetState(494)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(495)
			p.Match(XPath31ParserKW_ATTRIBUTE)
		}
		{
			p.SetState(496)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_SELF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(497)
			p.Match(XPath31ParserKW_SELF)
		}
		{
			p.SetState(498)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_DESCENDANT_OR_SELF:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(499)
			p.Match(XPath31ParserKW_DESCENDANT_OR_SELF)
		}
		{
			p.SetState(500)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_FOLLOWING_SIBLING:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(501)
			p.Match(XPath31ParserKW_FOLLOWING_SIBLING)
		}
		{
			p.SetState(502)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_FOLLOWING:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(503)
			p.Match(XPath31ParserKW_FOLLOWING)
		}
		{
			p.SetState(504)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_NAMESPACE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(505)
			p.Match(XPath31ParserKW_NAMESPACE)
		}
		{
			p.SetState(506)
			p.Match(XPath31ParserCOLONCOLON)
		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IAbbrevforwardstepContext is an interface to support dynamic dispatch.
type IAbbrevforwardstepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbbrevforwardstepContext differentiates from other interfaces.
	IsAbbrevforwardstepContext()
}

type AbbrevforwardstepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbrevforwardstepContext() *AbbrevforwardstepContext {
	var p = new(AbbrevforwardstepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_abbrevforwardstep
	return p
}

func (*AbbrevforwardstepContext) IsAbbrevforwardstepContext() {}

func NewAbbrevforwardstepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevforwardstepContext {
	var p = new(AbbrevforwardstepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_abbrevforwardstep

	return p
}

func (s *AbbrevforwardstepContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbrevforwardstepContext) Nodetest() INodetestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodetestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodetestContext)
}

func (s *AbbrevforwardstepContext) AT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserAT, 0)
}

func (s *AbbrevforwardstepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevforwardstepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AbbrevforwardstepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAbbrevforwardstep(s)
	}
}

func (s *AbbrevforwardstepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAbbrevforwardstep(s)
	}
}




func (p *XPath31Parser) Abbrevforwardstep() (localctx IAbbrevforwardstepContext) {
	localctx = NewAbbrevforwardstepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, XPath31ParserRULE_abbrevforwardstep)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserAT {
		{
			p.SetState(509)
			p.Match(XPath31ParserAT)
		}

	}
	{
		p.SetState(512)
		p.Nodetest()
	}



	return localctx
}


// IReversestepContext is an interface to support dynamic dispatch.
type IReversestepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReversestepContext differentiates from other interfaces.
	IsReversestepContext()
}

type ReversestepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReversestepContext() *ReversestepContext {
	var p = new(ReversestepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_reversestep
	return p
}

func (*ReversestepContext) IsReversestepContext() {}

func NewReversestepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReversestepContext {
	var p = new(ReversestepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_reversestep

	return p
}

func (s *ReversestepContext) GetParser() antlr.Parser { return s.parser }

func (s *ReversestepContext) Reverseaxis() IReverseaxisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReverseaxisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReverseaxisContext)
}

func (s *ReversestepContext) Nodetest() INodetestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INodetestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INodetestContext)
}

func (s *ReversestepContext) Abbrevreversestep() IAbbrevreversestepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAbbrevreversestepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAbbrevreversestepContext)
}

func (s *ReversestepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReversestepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReversestepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterReversestep(s)
	}
}

func (s *ReversestepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitReversestep(s)
	}
}




func (p *XPath31Parser) Reversestep() (localctx IReversestepContext) {
	localctx = NewReversestepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, XPath31ParserRULE_reversestep)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_ANCESTOR, XPath31ParserKW_ANCESTOR_OR_SELF, XPath31ParserKW_PARENT, XPath31ParserKW_PRECEDING, XPath31ParserKW_PRECEDING_SIBLING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(514)
			p.Reverseaxis()
		}
		{
			p.SetState(515)
			p.Nodetest()
		}



	case XPath31ParserDD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(517)
			p.Abbrevreversestep()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IReverseaxisContext is an interface to support dynamic dispatch.
type IReverseaxisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReverseaxisContext differentiates from other interfaces.
	IsReverseaxisContext()
}

type ReverseaxisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseaxisContext() *ReverseaxisContext {
	var p = new(ReverseaxisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_reverseaxis
	return p
}

func (*ReverseaxisContext) IsReverseaxisContext() {}

func NewReverseaxisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseaxisContext {
	var p = new(ReverseaxisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_reverseaxis

	return p
}

func (s *ReverseaxisContext) GetParser() antlr.Parser { return s.parser }

func (s *ReverseaxisContext) KW_PARENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PARENT, 0)
}

func (s *ReverseaxisContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOLONCOLON, 0)
}

func (s *ReverseaxisContext) KW_ANCESTOR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ANCESTOR, 0)
}

func (s *ReverseaxisContext) KW_PRECEDING_SIBLING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PRECEDING_SIBLING, 0)
}

func (s *ReverseaxisContext) KW_PRECEDING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PRECEDING, 0)
}

func (s *ReverseaxisContext) KW_ANCESTOR_OR_SELF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ANCESTOR_OR_SELF, 0)
}

func (s *ReverseaxisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseaxisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReverseaxisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterReverseaxis(s)
	}
}

func (s *ReverseaxisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitReverseaxis(s)
	}
}




func (p *XPath31Parser) Reverseaxis() (localctx IReverseaxisContext) {
	localctx = NewReverseaxisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, XPath31ParserRULE_reverseaxis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(530)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_PARENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(520)
			p.Match(XPath31ParserKW_PARENT)
		}
		{
			p.SetState(521)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_ANCESTOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(522)
			p.Match(XPath31ParserKW_ANCESTOR)
		}
		{
			p.SetState(523)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_PRECEDING_SIBLING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(524)
			p.Match(XPath31ParserKW_PRECEDING_SIBLING)
		}
		{
			p.SetState(525)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_PRECEDING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(526)
			p.Match(XPath31ParserKW_PRECEDING)
		}
		{
			p.SetState(527)
			p.Match(XPath31ParserCOLONCOLON)
		}



	case XPath31ParserKW_ANCESTOR_OR_SELF:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(528)
			p.Match(XPath31ParserKW_ANCESTOR_OR_SELF)
		}
		{
			p.SetState(529)
			p.Match(XPath31ParserCOLONCOLON)
		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IAbbrevreversestepContext is an interface to support dynamic dispatch.
type IAbbrevreversestepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbbrevreversestepContext differentiates from other interfaces.
	IsAbbrevreversestepContext()
}

type AbbrevreversestepContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbrevreversestepContext() *AbbrevreversestepContext {
	var p = new(AbbrevreversestepContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_abbrevreversestep
	return p
}

func (*AbbrevreversestepContext) IsAbbrevreversestepContext() {}

func NewAbbrevreversestepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbrevreversestepContext {
	var p = new(AbbrevreversestepContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_abbrevreversestep

	return p
}

func (s *AbbrevreversestepContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbrevreversestepContext) DD() antlr.TerminalNode {
	return s.GetToken(XPath31ParserDD, 0)
}

func (s *AbbrevreversestepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbrevreversestepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AbbrevreversestepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAbbrevreversestep(s)
	}
}

func (s *AbbrevreversestepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAbbrevreversestep(s)
	}
}




func (p *XPath31Parser) Abbrevreversestep() (localctx IAbbrevreversestepContext) {
	localctx = NewAbbrevreversestepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, XPath31ParserRULE_abbrevreversestep)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(532)
		p.Match(XPath31ParserDD)
	}



	return localctx
}


// INodetestContext is an interface to support dynamic dispatch.
type INodetestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNodetestContext differentiates from other interfaces.
	IsNodetestContext()
}

type NodetestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNodetestContext() *NodetestContext {
	var p = new(NodetestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_nodetest
	return p
}

func (*NodetestContext) IsNodetestContext() {}

func NewNodetestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NodetestContext {
	var p = new(NodetestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_nodetest

	return p
}

func (s *NodetestContext) GetParser() antlr.Parser { return s.parser }

func (s *NodetestContext) Kindtest() IKindtestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKindtestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKindtestContext)
}

func (s *NodetestContext) Nametest() INametestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INametestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INametestContext)
}

func (s *NodetestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NodetestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NodetestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterNodetest(s)
	}
}

func (s *NodetestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitNodetest(s)
	}
}




func (p *XPath31Parser) Nodetest() (localctx INodetestContext) {
	localctx = NewNodetestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, XPath31ParserRULE_nodetest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(534)
			p.Kindtest()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(535)
			p.Nametest()
		}

	}


	return localctx
}


// INametestContext is an interface to support dynamic dispatch.
type INametestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNametestContext differentiates from other interfaces.
	IsNametestContext()
}

type NametestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNametestContext() *NametestContext {
	var p = new(NametestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_nametest
	return p
}

func (*NametestContext) IsNametestContext() {}

func NewNametestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NametestContext {
	var p = new(NametestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_nametest

	return p
}

func (s *NametestContext) GetParser() antlr.Parser { return s.parser }

func (s *NametestContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *NametestContext) Wildcard() IWildcardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWildcardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWildcardContext)
}

func (s *NametestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NametestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NametestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterNametest(s)
	}
}

func (s *NametestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitNametest(s)
	}
}




func (p *XPath31Parser) Nametest() (localctx INametestContext) {
	localctx = NewNametestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, XPath31ParserRULE_nametest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(540)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_ANCESTOR, XPath31ParserKW_ANCESTOR_OR_SELF, XPath31ParserKW_AND, XPath31ParserKW_ARRAY, XPath31ParserKW_AS, XPath31ParserKW_ATTRIBUTE, XPath31ParserKW_CAST, XPath31ParserKW_CASTABLE, XPath31ParserKW_CHILD, XPath31ParserKW_COMMENT, XPath31ParserKW_DESCENDANT, XPath31ParserKW_DESCENDANT_OR_SELF, XPath31ParserKW_DIV, XPath31ParserKW_DOCUMENT_NODE, XPath31ParserKW_ELEMENT, XPath31ParserKW_ELSE, XPath31ParserKW_EMPTY_SEQUENCE, XPath31ParserKW_EQ, XPath31ParserKW_EVERY, XPath31ParserKW_EXCEPT, XPath31ParserKW_FOLLOWING, XPath31ParserKW_FOLLOWING_SIBLING, XPath31ParserKW_FOR, XPath31ParserKW_FUNCTION, XPath31ParserKW_GE, XPath31ParserKW_GT, XPath31ParserKW_IDIV, XPath31ParserKW_IF, XPath31ParserKW_IN, XPath31ParserKW_INSTANCE, XPath31ParserKW_INTERSECT, XPath31ParserKW_IS, XPath31ParserKW_ITEM, XPath31ParserKW_LE, XPath31ParserKW_LET, XPath31ParserKW_LT, XPath31ParserKW_MAP, XPath31ParserKW_MOD, XPath31ParserKW_NAMESPACE, XPath31ParserKW_NAMESPACE_NODE, XPath31ParserKW_NE, XPath31ParserKW_NODE, XPath31ParserKW_OF, XPath31ParserKW_OR, XPath31ParserKW_PARENT, XPath31ParserKW_PRECEDING, XPath31ParserKW_PRECEDING_SIBLING, XPath31ParserKW_PROCESSING_INSTRUCTION, XPath31ParserKW_RETURN, XPath31ParserKW_SATISFIES, XPath31ParserKW_SCHEMA_ATTRIBUTE, XPath31ParserKW_SCHEMA_ELEMENT, XPath31ParserKW_SELF, XPath31ParserKW_SOME, XPath31ParserKW_TEXT, XPath31ParserKW_THEN, XPath31ParserKW_TREAT, XPath31ParserKW_UNION, XPath31ParserURIQualifiedName, XPath31ParserQName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(538)
			p.Eqname()
		}


	case XPath31ParserSC, XPath31ParserSTAR, XPath31ParserBracedURILiteral, XPath31ParserNCName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(539)
			p.Wildcard()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IWildcardContext is an interface to support dynamic dispatch.
type IWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWildcardContext differentiates from other interfaces.
	IsWildcardContext()
}

type WildcardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardContext() *WildcardContext {
	var p = new(WildcardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_wildcard
	return p
}

func (*WildcardContext) IsWildcardContext() {}

func NewWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardContext {
	var p = new(WildcardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_wildcard

	return p
}

func (s *WildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *WildcardContext) NCName() antlr.TerminalNode {
	return s.GetToken(XPath31ParserNCName, 0)
}

func (s *WildcardContext) CS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCS, 0)
}

func (s *WildcardContext) SC() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSC, 0)
}

func (s *WildcardContext) BracedURILiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserBracedURILiteral, 0)
}

func (s *WildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterWildcard(s)
	}
}

func (s *WildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitWildcard(s)
	}
}




func (p *XPath31Parser) Wildcard() (localctx IWildcardContext) {
	localctx = NewWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, XPath31ParserRULE_wildcard)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(549)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserSTAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(542)
			p.Match(XPath31ParserSTAR)
		}


	case XPath31ParserNCName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(543)
			p.Match(XPath31ParserNCName)
		}
		{
			p.SetState(544)
			p.Match(XPath31ParserCS)
		}



	case XPath31ParserSC:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(545)
			p.Match(XPath31ParserSC)
		}
		{
			p.SetState(546)
			p.Match(XPath31ParserNCName)
		}



	case XPath31ParserBracedURILiteral:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(547)
			p.Match(XPath31ParserBracedURILiteral)
		}
		{
			p.SetState(548)
			p.Match(XPath31ParserSTAR)
		}




	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IPostfixexprContext is an interface to support dynamic dispatch.
type IPostfixexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPostfixexprContext differentiates from other interfaces.
	IsPostfixexprContext()
}

type PostfixexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixexprContext() *PostfixexprContext {
	var p = new(PostfixexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_postfixexpr
	return p
}

func (*PostfixexprContext) IsPostfixexprContext() {}

func NewPostfixexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixexprContext {
	var p = new(PostfixexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_postfixexpr

	return p
}

func (s *PostfixexprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixexprContext) Primaryexpr() IPrimaryexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryexprContext)
}

func (s *PostfixexprContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *PostfixexprContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PostfixexprContext) AllArgumentlist() []IArgumentlistContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentlistContext)(nil)).Elem())
	var tst = make([]IArgumentlistContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentlistContext)
		}
	}

	return tst
}

func (s *PostfixexprContext) Argumentlist(i int) IArgumentlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentlistContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentlistContext)
}

func (s *PostfixexprContext) AllLookup() []ILookupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILookupContext)(nil)).Elem())
	var tst = make([]ILookupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILookupContext)
		}
	}

	return tst
}

func (s *PostfixexprContext) Lookup(i int) ILookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILookupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILookupContext)
}

func (s *PostfixexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PostfixexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterPostfixexpr(s)
	}
}

func (s *PostfixexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitPostfixexpr(s)
	}
}




func (p *XPath31Parser) Postfixexpr() (localctx IPostfixexprContext) {
	localctx = NewPostfixexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, XPath31ParserRULE_postfixexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Primaryexpr()
	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for (((_la) & -(0x1f+1)) == 0 && ((1 << uint(_la)) & ((1 << XPath31ParserOB) | (1 << XPath31ParserOP) | (1 << XPath31ParserQM))) != 0) {
		p.SetState(555)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case XPath31ParserOB:
			{
				p.SetState(552)
				p.Predicate()
			}


		case XPath31ParserOP:
			{
				p.SetState(553)
				p.Argumentlist()
			}


		case XPath31ParserQM:
			{
				p.SetState(554)
				p.Lookup()
			}



		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IArgumentlistContext is an interface to support dynamic dispatch.
type IArgumentlistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentlistContext differentiates from other interfaces.
	IsArgumentlistContext()
}

type ArgumentlistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentlistContext() *ArgumentlistContext {
	var p = new(ArgumentlistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_argumentlist
	return p
}

func (*ArgumentlistContext) IsArgumentlistContext() {}

func NewArgumentlistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentlistContext {
	var p = new(ArgumentlistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_argumentlist

	return p
}

func (s *ArgumentlistContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentlistContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *ArgumentlistContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *ArgumentlistContext) AllArgument() []IArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentContext)(nil)).Elem())
	var tst = make([]IArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentContext)
		}
	}

	return tst
}

func (s *ArgumentlistContext) Argument(i int) IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentlistContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *ArgumentlistContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *ArgumentlistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentlistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentlistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterArgumentlist(s)
	}
}

func (s *ArgumentlistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitArgumentlist(s)
	}
}




func (p *XPath31Parser) Argumentlist() (localctx IArgumentlistContext) {
	localctx = NewArgumentlistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, XPath31ParserRULE_argumentlist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)
		p.Match(XPath31ParserOP)
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(561)
			p.Argument()
		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == XPath31ParserCOMMA {
			{
				p.SetState(562)
				p.Match(XPath31ParserCOMMA)
			}
			{
				p.SetState(563)
				p.Argument()
			}


			p.SetState(568)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	}
	{
		p.SetState(571)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IPredicatelistContext is an interface to support dynamic dispatch.
type IPredicatelistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicatelistContext differentiates from other interfaces.
	IsPredicatelistContext()
}

type PredicatelistContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicatelistContext() *PredicatelistContext {
	var p = new(PredicatelistContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_predicatelist
	return p
}

func (*PredicatelistContext) IsPredicatelistContext() {}

func NewPredicatelistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicatelistContext {
	var p = new(PredicatelistContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_predicatelist

	return p
}

func (s *PredicatelistContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicatelistContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *PredicatelistContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatelistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatelistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PredicatelistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterPredicatelist(s)
	}
}

func (s *PredicatelistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitPredicatelist(s)
	}
}




func (p *XPath31Parser) Predicatelist() (localctx IPredicatelistContext) {
	localctx = NewPredicatelistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, XPath31ParserRULE_predicatelist)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	for _la == XPath31ParserOB {
		{
			p.SetState(573)
			p.Predicate()
		}


		p.SetState(578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}



	return localctx
}


// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) OB() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOB, 0)
}

func (s *PredicateContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PredicateContext) CB() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCB, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitPredicate(s)
	}
}




func (p *XPath31Parser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, XPath31ParserRULE_predicate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(XPath31ParserOB)
	}
	{
		p.SetState(580)
		p.Expr()
	}
	{
		p.SetState(581)
		p.Match(XPath31ParserCB)
	}



	return localctx
}


// ILookupContext is an interface to support dynamic dispatch.
type ILookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLookupContext differentiates from other interfaces.
	IsLookupContext()
}

type LookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookupContext() *LookupContext {
	var p = new(LookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_lookup
	return p
}

func (*LookupContext) IsLookupContext() {}

func NewLookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupContext {
	var p = new(LookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_lookup

	return p
}

func (s *LookupContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupContext) QM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserQM, 0)
}

func (s *LookupContext) Keyspecifier() IKeyspecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyspecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyspecifierContext)
}

func (s *LookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterLookup(s)
	}
}

func (s *LookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitLookup(s)
	}
}




func (p *XPath31Parser) Lookup() (localctx ILookupContext) {
	localctx = NewLookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, XPath31ParserRULE_lookup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(583)
		p.Match(XPath31ParserQM)
	}
	{
		p.SetState(584)
		p.Keyspecifier()
	}



	return localctx
}


// IKeyspecifierContext is an interface to support dynamic dispatch.
type IKeyspecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyspecifierContext differentiates from other interfaces.
	IsKeyspecifierContext()
}

type KeyspecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyspecifierContext() *KeyspecifierContext {
	var p = new(KeyspecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_keyspecifier
	return p
}

func (*KeyspecifierContext) IsKeyspecifierContext() {}

func NewKeyspecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyspecifierContext {
	var p = new(KeyspecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_keyspecifier

	return p
}

func (s *KeyspecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyspecifierContext) NCName() antlr.TerminalNode {
	return s.GetToken(XPath31ParserNCName, 0)
}

func (s *KeyspecifierContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserIntegerLiteral, 0)
}

func (s *KeyspecifierContext) Parenthesizedexpr() IParenthesizedexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedexprContext)
}

func (s *KeyspecifierContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *KeyspecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyspecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeyspecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterKeyspecifier(s)
	}
}

func (s *KeyspecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitKeyspecifier(s)
	}
}




func (p *XPath31Parser) Keyspecifier() (localctx IKeyspecifierContext) {
	localctx = NewKeyspecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, XPath31ParserRULE_keyspecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(590)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserNCName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(586)
			p.Match(XPath31ParserNCName)
		}


	case XPath31ParserIntegerLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(587)
			p.Match(XPath31ParserIntegerLiteral)
		}


	case XPath31ParserOP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(588)
			p.Parenthesizedexpr()
		}


	case XPath31ParserSTAR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(589)
			p.Match(XPath31ParserSTAR)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IArrowfunctionspecifierContext is an interface to support dynamic dispatch.
type IArrowfunctionspecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrowfunctionspecifierContext differentiates from other interfaces.
	IsArrowfunctionspecifierContext()
}

type ArrowfunctionspecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrowfunctionspecifierContext() *ArrowfunctionspecifierContext {
	var p = new(ArrowfunctionspecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_arrowfunctionspecifier
	return p
}

func (*ArrowfunctionspecifierContext) IsArrowfunctionspecifierContext() {}

func NewArrowfunctionspecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrowfunctionspecifierContext {
	var p = new(ArrowfunctionspecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_arrowfunctionspecifier

	return p
}

func (s *ArrowfunctionspecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrowfunctionspecifierContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *ArrowfunctionspecifierContext) Varref() IVarrefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarrefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarrefContext)
}

func (s *ArrowfunctionspecifierContext) Parenthesizedexpr() IParenthesizedexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedexprContext)
}

func (s *ArrowfunctionspecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowfunctionspecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrowfunctionspecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterArrowfunctionspecifier(s)
	}
}

func (s *ArrowfunctionspecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitArrowfunctionspecifier(s)
	}
}




func (p *XPath31Parser) Arrowfunctionspecifier() (localctx IArrowfunctionspecifierContext) {
	localctx = NewArrowfunctionspecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, XPath31ParserRULE_arrowfunctionspecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(595)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_ANCESTOR, XPath31ParserKW_ANCESTOR_OR_SELF, XPath31ParserKW_AND, XPath31ParserKW_ARRAY, XPath31ParserKW_AS, XPath31ParserKW_ATTRIBUTE, XPath31ParserKW_CAST, XPath31ParserKW_CASTABLE, XPath31ParserKW_CHILD, XPath31ParserKW_COMMENT, XPath31ParserKW_DESCENDANT, XPath31ParserKW_DESCENDANT_OR_SELF, XPath31ParserKW_DIV, XPath31ParserKW_DOCUMENT_NODE, XPath31ParserKW_ELEMENT, XPath31ParserKW_ELSE, XPath31ParserKW_EMPTY_SEQUENCE, XPath31ParserKW_EQ, XPath31ParserKW_EVERY, XPath31ParserKW_EXCEPT, XPath31ParserKW_FOLLOWING, XPath31ParserKW_FOLLOWING_SIBLING, XPath31ParserKW_FOR, XPath31ParserKW_FUNCTION, XPath31ParserKW_GE, XPath31ParserKW_GT, XPath31ParserKW_IDIV, XPath31ParserKW_IF, XPath31ParserKW_IN, XPath31ParserKW_INSTANCE, XPath31ParserKW_INTERSECT, XPath31ParserKW_IS, XPath31ParserKW_ITEM, XPath31ParserKW_LE, XPath31ParserKW_LET, XPath31ParserKW_LT, XPath31ParserKW_MAP, XPath31ParserKW_MOD, XPath31ParserKW_NAMESPACE, XPath31ParserKW_NAMESPACE_NODE, XPath31ParserKW_NE, XPath31ParserKW_NODE, XPath31ParserKW_OF, XPath31ParserKW_OR, XPath31ParserKW_PARENT, XPath31ParserKW_PRECEDING, XPath31ParserKW_PRECEDING_SIBLING, XPath31ParserKW_PROCESSING_INSTRUCTION, XPath31ParserKW_RETURN, XPath31ParserKW_SATISFIES, XPath31ParserKW_SCHEMA_ATTRIBUTE, XPath31ParserKW_SCHEMA_ELEMENT, XPath31ParserKW_SELF, XPath31ParserKW_SOME, XPath31ParserKW_TEXT, XPath31ParserKW_THEN, XPath31ParserKW_TREAT, XPath31ParserKW_UNION, XPath31ParserURIQualifiedName, XPath31ParserQName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(592)
			p.Eqname()
		}


	case XPath31ParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(593)
			p.Varref()
		}


	case XPath31ParserOP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(594)
			p.Parenthesizedexpr()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IPrimaryexprContext is an interface to support dynamic dispatch.
type IPrimaryexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryexprContext differentiates from other interfaces.
	IsPrimaryexprContext()
}

type PrimaryexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryexprContext() *PrimaryexprContext {
	var p = new(PrimaryexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_primaryexpr
	return p
}

func (*PrimaryexprContext) IsPrimaryexprContext() {}

func NewPrimaryexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryexprContext {
	var p = new(PrimaryexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_primaryexpr

	return p
}

func (s *PrimaryexprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryexprContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryexprContext) Varref() IVarrefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarrefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarrefContext)
}

func (s *PrimaryexprContext) Parenthesizedexpr() IParenthesizedexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizedexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizedexprContext)
}

func (s *PrimaryexprContext) Contextitemexpr() IContextitemexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContextitemexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContextitemexprContext)
}

func (s *PrimaryexprContext) Functioncall() IFunctioncallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctioncallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctioncallContext)
}

func (s *PrimaryexprContext) Functionitemexpr() IFunctionitemexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionitemexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionitemexprContext)
}

func (s *PrimaryexprContext) Mapconstructor() IMapconstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapconstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapconstructorContext)
}

func (s *PrimaryexprContext) Arrayconstructor() IArrayconstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayconstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayconstructorContext)
}

func (s *PrimaryexprContext) Unarylookup() IUnarylookupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnarylookupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnarylookupContext)
}

func (s *PrimaryexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PrimaryexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterPrimaryexpr(s)
	}
}

func (s *PrimaryexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitPrimaryexpr(s)
	}
}




func (p *XPath31Parser) Primaryexpr() (localctx IPrimaryexprContext) {
	localctx = NewPrimaryexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, XPath31ParserRULE_primaryexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(597)
			p.Literal()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(598)
			p.Varref()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(599)
			p.Parenthesizedexpr()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(600)
			p.Contextitemexpr()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(601)
			p.Functioncall()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(602)
			p.Functionitemexpr()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(603)
			p.Mapconstructor()
		}


	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(604)
			p.Arrayconstructor()
		}


	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(605)
			p.Unarylookup()
		}

	}


	return localctx
}


// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) Numericliteral() INumericliteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericliteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericliteralContext)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserStringLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitLiteral(s)
	}
}




func (p *XPath31Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, XPath31ParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(610)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserIntegerLiteral, XPath31ParserDecimalLiteral, XPath31ParserDoubleLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.Numericliteral()
		}


	case XPath31ParserStringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(609)
			p.Match(XPath31ParserStringLiteral)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// INumericliteralContext is an interface to support dynamic dispatch.
type INumericliteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericliteralContext differentiates from other interfaces.
	IsNumericliteralContext()
}

type NumericliteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericliteralContext() *NumericliteralContext {
	var p = new(NumericliteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_numericliteral
	return p
}

func (*NumericliteralContext) IsNumericliteralContext() {}

func NewNumericliteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericliteralContext {
	var p = new(NumericliteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_numericliteral

	return p
}

func (s *NumericliteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericliteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserIntegerLiteral, 0)
}

func (s *NumericliteralContext) DecimalLiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserDecimalLiteral, 0)
}

func (s *NumericliteralContext) DoubleLiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserDoubleLiteral, 0)
}

func (s *NumericliteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericliteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NumericliteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterNumericliteral(s)
	}
}

func (s *NumericliteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitNumericliteral(s)
	}
}




func (p *XPath31Parser) Numericliteral() (localctx INumericliteralContext) {
	localctx = NewNumericliteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, XPath31ParserRULE_numericliteral)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 95)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 95))) & ((1 << (XPath31ParserIntegerLiteral - 95)) | (1 << (XPath31ParserDecimalLiteral - 95)) | (1 << (XPath31ParserDoubleLiteral - 95)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IVarrefContext is an interface to support dynamic dispatch.
type IVarrefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarrefContext differentiates from other interfaces.
	IsVarrefContext()
}

type VarrefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarrefContext() *VarrefContext {
	var p = new(VarrefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_varref
	return p
}

func (*VarrefContext) IsVarrefContext() {}

func NewVarrefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarrefContext {
	var p = new(VarrefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_varref

	return p
}

func (s *VarrefContext) GetParser() antlr.Parser { return s.parser }

func (s *VarrefContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserDOLLAR, 0)
}

func (s *VarrefContext) Varname() IVarnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVarnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVarnameContext)
}

func (s *VarrefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarrefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VarrefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterVarref(s)
	}
}

func (s *VarrefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitVarref(s)
	}
}




func (p *XPath31Parser) Varref() (localctx IVarrefContext) {
	localctx = NewVarrefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, XPath31ParserRULE_varref)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(614)
		p.Match(XPath31ParserDOLLAR)
	}
	{
		p.SetState(615)
		p.Varname()
	}



	return localctx
}


// IVarnameContext is an interface to support dynamic dispatch.
type IVarnameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVarnameContext differentiates from other interfaces.
	IsVarnameContext()
}

type VarnameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarnameContext() *VarnameContext {
	var p = new(VarnameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_varname
	return p
}

func (*VarnameContext) IsVarnameContext() {}

func NewVarnameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarnameContext {
	var p = new(VarnameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_varname

	return p
}

func (s *VarnameContext) GetParser() antlr.Parser { return s.parser }

func (s *VarnameContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *VarnameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarnameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VarnameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterVarname(s)
	}
}

func (s *VarnameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitVarname(s)
	}
}




func (p *XPath31Parser) Varname() (localctx IVarnameContext) {
	localctx = NewVarnameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, XPath31ParserRULE_varname)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Eqname()
	}



	return localctx
}


// IParenthesizedexprContext is an interface to support dynamic dispatch.
type IParenthesizedexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizedexprContext differentiates from other interfaces.
	IsParenthesizedexprContext()
}

type ParenthesizedexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizedexprContext() *ParenthesizedexprContext {
	var p = new(ParenthesizedexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_parenthesizedexpr
	return p
}

func (*ParenthesizedexprContext) IsParenthesizedexprContext() {}

func NewParenthesizedexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizedexprContext {
	var p = new(ParenthesizedexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_parenthesizedexpr

	return p
}

func (s *ParenthesizedexprContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizedexprContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *ParenthesizedexprContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *ParenthesizedexprContext) Expr() IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParenthesizedexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParenthesizedexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterParenthesizedexpr(s)
	}
}

func (s *ParenthesizedexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitParenthesizedexpr(s)
	}
}




func (p *XPath31Parser) Parenthesizedexpr() (localctx IParenthesizedexprContext) {
	localctx = NewParenthesizedexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, XPath31ParserRULE_parenthesizedexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.Match(XPath31ParserOP)
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(620)
			p.Expr()
		}


	}
	{
		p.SetState(623)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IContextitemexprContext is an interface to support dynamic dispatch.
type IContextitemexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContextitemexprContext differentiates from other interfaces.
	IsContextitemexprContext()
}

type ContextitemexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextitemexprContext() *ContextitemexprContext {
	var p = new(ContextitemexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_contextitemexpr
	return p
}

func (*ContextitemexprContext) IsContextitemexprContext() {}

func NewContextitemexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextitemexprContext {
	var p = new(ContextitemexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_contextitemexpr

	return p
}

func (s *ContextitemexprContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextitemexprContext) D() antlr.TerminalNode {
	return s.GetToken(XPath31ParserD, 0)
}

func (s *ContextitemexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextitemexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContextitemexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterContextitemexpr(s)
	}
}

func (s *ContextitemexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitContextitemexpr(s)
	}
}




func (p *XPath31Parser) Contextitemexpr() (localctx IContextitemexprContext) {
	localctx = NewContextitemexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, XPath31ParserRULE_contextitemexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(XPath31ParserD)
	}



	return localctx
}


// IFunctioncallContext is an interface to support dynamic dispatch.
type IFunctioncallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctioncallContext differentiates from other interfaces.
	IsFunctioncallContext()
}

type FunctioncallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctioncallContext() *FunctioncallContext {
	var p = new(FunctioncallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_functioncall
	return p
}

func (*FunctioncallContext) IsFunctioncallContext() {}

func NewFunctioncallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctioncallContext {
	var p = new(FunctioncallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_functioncall

	return p
}

func (s *FunctioncallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctioncallContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *FunctioncallContext) Argumentlist() IArgumentlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentlistContext)
}

func (s *FunctioncallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctioncallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctioncallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterFunctioncall(s)
	}
}

func (s *FunctioncallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitFunctioncall(s)
	}
}




func (p *XPath31Parser) Functioncall() (localctx IFunctioncallContext) {
	localctx = NewFunctioncallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, XPath31ParserRULE_functioncall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(627)

	if !( !(p.GetInputStream().LA(1)==XPath31ParserKW_ARRAY ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_ATTRIBUTE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_COMMENT ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_DOCUMENT_NODE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_ELEMENT ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_EMPTY_SEQUENCE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_FUNCTION ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_IF ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_ITEM ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_MAP ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_NAMESPACE_NODE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_NODE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_PROCESSING_INSTRUCTION ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_SCHEMA_ATTRIBUTE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_SCHEMA_ELEMENT ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_TEXT) ) {
		panic(antlr.NewFailedPredicateException(p, " !(p.GetInputStream().LA(1)==XPath31ParserKW_ARRAY ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_ATTRIBUTE ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_COMMENT ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_DOCUMENT_NODE ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_ELEMENT ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_EMPTY_SEQUENCE ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_FUNCTION ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_IF ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_ITEM ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_MAP ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_NAMESPACE_NODE ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_NODE ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_PROCESSING_INSTRUCTION ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_SCHEMA_ATTRIBUTE ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_SCHEMA_ELEMENT ||\n                          p.GetInputStream().LA(1)==XPath31ParserKW_TEXT) ", ""))
	}
	{
		p.SetState(628)
		p.Eqname()
	}
	{
		p.SetState(629)
		p.Argumentlist()
	}



	return localctx
}


// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Exprsingle() IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *ArgumentContext) Argumentplaceholder() IArgumentplaceholderContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentplaceholderContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentplaceholderContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitArgument(s)
	}
}




func (p *XPath31Parser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, XPath31ParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Exprsingle()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Argumentplaceholder()
		}

	}


	return localctx
}


// IArgumentplaceholderContext is an interface to support dynamic dispatch.
type IArgumentplaceholderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentplaceholderContext differentiates from other interfaces.
	IsArgumentplaceholderContext()
}

type ArgumentplaceholderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentplaceholderContext() *ArgumentplaceholderContext {
	var p = new(ArgumentplaceholderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_argumentplaceholder
	return p
}

func (*ArgumentplaceholderContext) IsArgumentplaceholderContext() {}

func NewArgumentplaceholderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentplaceholderContext {
	var p = new(ArgumentplaceholderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_argumentplaceholder

	return p
}

func (s *ArgumentplaceholderContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentplaceholderContext) QM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserQM, 0)
}

func (s *ArgumentplaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentplaceholderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArgumentplaceholderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterArgumentplaceholder(s)
	}
}

func (s *ArgumentplaceholderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitArgumentplaceholder(s)
	}
}




func (p *XPath31Parser) Argumentplaceholder() (localctx IArgumentplaceholderContext) {
	localctx = NewArgumentplaceholderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, XPath31ParserRULE_argumentplaceholder)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		p.Match(XPath31ParserQM)
	}



	return localctx
}


// IFunctionitemexprContext is an interface to support dynamic dispatch.
type IFunctionitemexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionitemexprContext differentiates from other interfaces.
	IsFunctionitemexprContext()
}

type FunctionitemexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionitemexprContext() *FunctionitemexprContext {
	var p = new(FunctionitemexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_functionitemexpr
	return p
}

func (*FunctionitemexprContext) IsFunctionitemexprContext() {}

func NewFunctionitemexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionitemexprContext {
	var p = new(FunctionitemexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_functionitemexpr

	return p
}

func (s *FunctionitemexprContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionitemexprContext) Namedfunctionref() INamedfunctionrefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedfunctionrefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedfunctionrefContext)
}

func (s *FunctionitemexprContext) Inlinefunctionexpr() IInlinefunctionexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlinefunctionexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInlinefunctionexprContext)
}

func (s *FunctionitemexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionitemexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionitemexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterFunctionitemexpr(s)
	}
}

func (s *FunctionitemexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitFunctionitemexpr(s)
	}
}




func (p *XPath31Parser) Functionitemexpr() (localctx IFunctionitemexprContext) {
	localctx = NewFunctionitemexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, XPath31ParserRULE_functionitemexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(637)
			p.Namedfunctionref()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(638)
			p.Inlinefunctionexpr()
		}

	}


	return localctx
}


// INamedfunctionrefContext is an interface to support dynamic dispatch.
type INamedfunctionrefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedfunctionrefContext differentiates from other interfaces.
	IsNamedfunctionrefContext()
}

type NamedfunctionrefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedfunctionrefContext() *NamedfunctionrefContext {
	var p = new(NamedfunctionrefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_namedfunctionref
	return p
}

func (*NamedfunctionrefContext) IsNamedfunctionrefContext() {}

func NewNamedfunctionrefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedfunctionrefContext {
	var p = new(NamedfunctionrefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_namedfunctionref

	return p
}

func (s *NamedfunctionrefContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedfunctionrefContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *NamedfunctionrefContext) POUND() antlr.TerminalNode {
	return s.GetToken(XPath31ParserPOUND, 0)
}

func (s *NamedfunctionrefContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserIntegerLiteral, 0)
}

func (s *NamedfunctionrefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedfunctionrefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NamedfunctionrefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterNamedfunctionref(s)
	}
}

func (s *NamedfunctionrefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitNamedfunctionref(s)
	}
}




func (p *XPath31Parser) Namedfunctionref() (localctx INamedfunctionrefContext) {
	localctx = NewNamedfunctionrefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, XPath31ParserRULE_namedfunctionref)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Eqname()
	}
	{
		p.SetState(642)
		p.Match(XPath31ParserPOUND)
	}
	{
		p.SetState(643)
		p.Match(XPath31ParserIntegerLiteral)
	}



	return localctx
}


// IInlinefunctionexprContext is an interface to support dynamic dispatch.
type IInlinefunctionexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlinefunctionexprContext differentiates from other interfaces.
	IsInlinefunctionexprContext()
}

type InlinefunctionexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlinefunctionexprContext() *InlinefunctionexprContext {
	var p = new(InlinefunctionexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_inlinefunctionexpr
	return p
}

func (*InlinefunctionexprContext) IsInlinefunctionexprContext() {}

func NewInlinefunctionexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinefunctionexprContext {
	var p = new(InlinefunctionexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_inlinefunctionexpr

	return p
}

func (s *InlinefunctionexprContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinefunctionexprContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FUNCTION, 0)
}

func (s *InlinefunctionexprContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *InlinefunctionexprContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *InlinefunctionexprContext) Functionbody() IFunctionbodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionbodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionbodyContext)
}

func (s *InlinefunctionexprContext) Paramlist() IParamlistContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamlistContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParamlistContext)
}

func (s *InlinefunctionexprContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AS, 0)
}

func (s *InlinefunctionexprContext) Sequencetype() ISequencetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequencetypeContext)
}

func (s *InlinefunctionexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinefunctionexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InlinefunctionexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterInlinefunctionexpr(s)
	}
}

func (s *InlinefunctionexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitInlinefunctionexpr(s)
	}
}




func (p *XPath31Parser) Inlinefunctionexpr() (localctx IInlinefunctionexprContext) {
	localctx = NewInlinefunctionexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, XPath31ParserRULE_inlinefunctionexpr)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Match(XPath31ParserKW_FUNCTION)
	}
	{
		p.SetState(646)
		p.Match(XPath31ParserOP)
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserDOLLAR {
		{
			p.SetState(647)
			p.Paramlist()
		}

	}
	{
		p.SetState(650)
		p.Match(XPath31ParserCP)
	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserKW_AS {
		{
			p.SetState(651)
			p.Match(XPath31ParserKW_AS)
		}
		{
			p.SetState(652)
			p.Sequencetype()
		}

	}
	{
		p.SetState(655)
		p.Functionbody()
	}



	return localctx
}


// IMapconstructorContext is an interface to support dynamic dispatch.
type IMapconstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapconstructorContext differentiates from other interfaces.
	IsMapconstructorContext()
}

type MapconstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapconstructorContext() *MapconstructorContext {
	var p = new(MapconstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_mapconstructor
	return p
}

func (*MapconstructorContext) IsMapconstructorContext() {}

func NewMapconstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapconstructorContext {
	var p = new(MapconstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_mapconstructor

	return p
}

func (s *MapconstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *MapconstructorContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_MAP, 0)
}

func (s *MapconstructorContext) OC() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOC, 0)
}

func (s *MapconstructorContext) CC() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCC, 0)
}

func (s *MapconstructorContext) AllMapconstructorentry() []IMapconstructorentryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMapconstructorentryContext)(nil)).Elem())
	var tst = make([]IMapconstructorentryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMapconstructorentryContext)
		}
	}

	return tst
}

func (s *MapconstructorContext) Mapconstructorentry(i int) IMapconstructorentryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapconstructorentryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMapconstructorentryContext)
}

func (s *MapconstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *MapconstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *MapconstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapconstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapconstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterMapconstructor(s)
	}
}

func (s *MapconstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitMapconstructor(s)
	}
}




func (p *XPath31Parser) Mapconstructor() (localctx IMapconstructorContext) {
	localctx = NewMapconstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, XPath31ParserRULE_mapconstructor)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(XPath31ParserKW_MAP)
	}
	{
		p.SetState(658)
		p.Match(XPath31ParserOC)
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(659)
			p.Mapconstructorentry()
		}
		p.SetState(664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == XPath31ParserCOMMA {
			{
				p.SetState(660)
				p.Match(XPath31ParserCOMMA)
			}
			{
				p.SetState(661)
				p.Mapconstructorentry()
			}


			p.SetState(666)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	}
	{
		p.SetState(669)
		p.Match(XPath31ParserCC)
	}



	return localctx
}


// IMapconstructorentryContext is an interface to support dynamic dispatch.
type IMapconstructorentryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapconstructorentryContext differentiates from other interfaces.
	IsMapconstructorentryContext()
}

type MapconstructorentryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapconstructorentryContext() *MapconstructorentryContext {
	var p = new(MapconstructorentryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_mapconstructorentry
	return p
}

func (*MapconstructorentryContext) IsMapconstructorentryContext() {}

func NewMapconstructorentryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapconstructorentryContext {
	var p = new(MapconstructorentryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_mapconstructorentry

	return p
}

func (s *MapconstructorentryContext) GetParser() antlr.Parser { return s.parser }

func (s *MapconstructorentryContext) Mapkeyexpr() IMapkeyexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapkeyexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapkeyexprContext)
}

func (s *MapconstructorentryContext) COLON() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOLON, 0)
}

func (s *MapconstructorentryContext) Mapvalueexpr() IMapvalueexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapvalueexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapvalueexprContext)
}

func (s *MapconstructorentryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapconstructorentryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapconstructorentryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterMapconstructorentry(s)
	}
}

func (s *MapconstructorentryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitMapconstructorentry(s)
	}
}




func (p *XPath31Parser) Mapconstructorentry() (localctx IMapconstructorentryContext) {
	localctx = NewMapconstructorentryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, XPath31ParserRULE_mapconstructorentry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Mapkeyexpr()
	}
	{
		p.SetState(672)
		p.Match(XPath31ParserCOLON)
	}
	{
		p.SetState(673)
		p.Mapvalueexpr()
	}



	return localctx
}


// IMapkeyexprContext is an interface to support dynamic dispatch.
type IMapkeyexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapkeyexprContext differentiates from other interfaces.
	IsMapkeyexprContext()
}

type MapkeyexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapkeyexprContext() *MapkeyexprContext {
	var p = new(MapkeyexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_mapkeyexpr
	return p
}

func (*MapkeyexprContext) IsMapkeyexprContext() {}

func NewMapkeyexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapkeyexprContext {
	var p = new(MapkeyexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_mapkeyexpr

	return p
}

func (s *MapkeyexprContext) GetParser() antlr.Parser { return s.parser }

func (s *MapkeyexprContext) Exprsingle() IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *MapkeyexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapkeyexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapkeyexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterMapkeyexpr(s)
	}
}

func (s *MapkeyexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitMapkeyexpr(s)
	}
}




func (p *XPath31Parser) Mapkeyexpr() (localctx IMapkeyexprContext) {
	localctx = NewMapkeyexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, XPath31ParserRULE_mapkeyexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.Exprsingle()
	}



	return localctx
}


// IMapvalueexprContext is an interface to support dynamic dispatch.
type IMapvalueexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapvalueexprContext differentiates from other interfaces.
	IsMapvalueexprContext()
}

type MapvalueexprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapvalueexprContext() *MapvalueexprContext {
	var p = new(MapvalueexprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_mapvalueexpr
	return p
}

func (*MapvalueexprContext) IsMapvalueexprContext() {}

func NewMapvalueexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapvalueexprContext {
	var p = new(MapvalueexprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_mapvalueexpr

	return p
}

func (s *MapvalueexprContext) GetParser() antlr.Parser { return s.parser }

func (s *MapvalueexprContext) Exprsingle() IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *MapvalueexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapvalueexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MapvalueexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterMapvalueexpr(s)
	}
}

func (s *MapvalueexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitMapvalueexpr(s)
	}
}




func (p *XPath31Parser) Mapvalueexpr() (localctx IMapvalueexprContext) {
	localctx = NewMapvalueexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, XPath31ParserRULE_mapvalueexpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(677)
		p.Exprsingle()
	}



	return localctx
}


// IArrayconstructorContext is an interface to support dynamic dispatch.
type IArrayconstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayconstructorContext differentiates from other interfaces.
	IsArrayconstructorContext()
}

type ArrayconstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayconstructorContext() *ArrayconstructorContext {
	var p = new(ArrayconstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_arrayconstructor
	return p
}

func (*ArrayconstructorContext) IsArrayconstructorContext() {}

func NewArrayconstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayconstructorContext {
	var p = new(ArrayconstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_arrayconstructor

	return p
}

func (s *ArrayconstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayconstructorContext) Squarearrayconstructor() ISquarearrayconstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquarearrayconstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISquarearrayconstructorContext)
}

func (s *ArrayconstructorContext) Curlyarrayconstructor() ICurlyarrayconstructorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICurlyarrayconstructorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICurlyarrayconstructorContext)
}

func (s *ArrayconstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayconstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArrayconstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterArrayconstructor(s)
	}
}

func (s *ArrayconstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitArrayconstructor(s)
	}
}




func (p *XPath31Parser) Arrayconstructor() (localctx IArrayconstructorContext) {
	localctx = NewArrayconstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, XPath31ParserRULE_arrayconstructor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(681)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserOB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(679)
			p.Squarearrayconstructor()
		}


	case XPath31ParserKW_ARRAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(680)
			p.Curlyarrayconstructor()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISquarearrayconstructorContext is an interface to support dynamic dispatch.
type ISquarearrayconstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquarearrayconstructorContext differentiates from other interfaces.
	IsSquarearrayconstructorContext()
}

type SquarearrayconstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquarearrayconstructorContext() *SquarearrayconstructorContext {
	var p = new(SquarearrayconstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_squarearrayconstructor
	return p
}

func (*SquarearrayconstructorContext) IsSquarearrayconstructorContext() {}

func NewSquarearrayconstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SquarearrayconstructorContext {
	var p = new(SquarearrayconstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_squarearrayconstructor

	return p
}

func (s *SquarearrayconstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *SquarearrayconstructorContext) OB() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOB, 0)
}

func (s *SquarearrayconstructorContext) CB() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCB, 0)
}

func (s *SquarearrayconstructorContext) AllExprsingle() []IExprsingleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprsingleContext)(nil)).Elem())
	var tst = make([]IExprsingleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprsingleContext)
		}
	}

	return tst
}

func (s *SquarearrayconstructorContext) Exprsingle(i int) IExprsingleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprsingleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprsingleContext)
}

func (s *SquarearrayconstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *SquarearrayconstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *SquarearrayconstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SquarearrayconstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SquarearrayconstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSquarearrayconstructor(s)
	}
}

func (s *SquarearrayconstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSquarearrayconstructor(s)
	}
}




func (p *XPath31Parser) Squarearrayconstructor() (localctx ISquarearrayconstructorContext) {
	localctx = NewSquarearrayconstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, XPath31ParserRULE_squarearrayconstructor)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		p.Match(XPath31ParserOB)
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(684)
			p.Exprsingle()
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == XPath31ParserCOMMA {
			{
				p.SetState(685)
				p.Match(XPath31ParserCOMMA)
			}
			{
				p.SetState(686)
				p.Exprsingle()
			}


			p.SetState(691)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}


	}
	{
		p.SetState(694)
		p.Match(XPath31ParserCB)
	}



	return localctx
}


// ICurlyarrayconstructorContext is an interface to support dynamic dispatch.
type ICurlyarrayconstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCurlyarrayconstructorContext differentiates from other interfaces.
	IsCurlyarrayconstructorContext()
}

type CurlyarrayconstructorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurlyarrayconstructorContext() *CurlyarrayconstructorContext {
	var p = new(CurlyarrayconstructorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_curlyarrayconstructor
	return p
}

func (*CurlyarrayconstructorContext) IsCurlyarrayconstructorContext() {}

func NewCurlyarrayconstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurlyarrayconstructorContext {
	var p = new(CurlyarrayconstructorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_curlyarrayconstructor

	return p
}

func (s *CurlyarrayconstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *CurlyarrayconstructorContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ARRAY, 0)
}

func (s *CurlyarrayconstructorContext) Enclosedexpr() IEnclosedexprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnclosedexprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnclosedexprContext)
}

func (s *CurlyarrayconstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurlyarrayconstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CurlyarrayconstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterCurlyarrayconstructor(s)
	}
}

func (s *CurlyarrayconstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitCurlyarrayconstructor(s)
	}
}




func (p *XPath31Parser) Curlyarrayconstructor() (localctx ICurlyarrayconstructorContext) {
	localctx = NewCurlyarrayconstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, XPath31ParserRULE_curlyarrayconstructor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Match(XPath31ParserKW_ARRAY)
	}
	{
		p.SetState(697)
		p.Enclosedexpr()
	}



	return localctx
}


// IUnarylookupContext is an interface to support dynamic dispatch.
type IUnarylookupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnarylookupContext differentiates from other interfaces.
	IsUnarylookupContext()
}

type UnarylookupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnarylookupContext() *UnarylookupContext {
	var p = new(UnarylookupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_unarylookup
	return p
}

func (*UnarylookupContext) IsUnarylookupContext() {}

func NewUnarylookupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnarylookupContext {
	var p = new(UnarylookupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_unarylookup

	return p
}

func (s *UnarylookupContext) GetParser() antlr.Parser { return s.parser }

func (s *UnarylookupContext) QM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserQM, 0)
}

func (s *UnarylookupContext) Keyspecifier() IKeyspecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyspecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyspecifierContext)
}

func (s *UnarylookupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnarylookupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnarylookupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterUnarylookup(s)
	}
}

func (s *UnarylookupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitUnarylookup(s)
	}
}




func (p *XPath31Parser) Unarylookup() (localctx IUnarylookupContext) {
	localctx = NewUnarylookupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, XPath31ParserRULE_unarylookup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		p.Match(XPath31ParserQM)
	}
	{
		p.SetState(700)
		p.Keyspecifier()
	}



	return localctx
}


// ISingletypeContext is an interface to support dynamic dispatch.
type ISingletypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingletypeContext differentiates from other interfaces.
	IsSingletypeContext()
}

type SingletypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingletypeContext() *SingletypeContext {
	var p = new(SingletypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_singletype
	return p
}

func (*SingletypeContext) IsSingletypeContext() {}

func NewSingletypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingletypeContext {
	var p = new(SingletypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_singletype

	return p
}

func (s *SingletypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SingletypeContext) Simpletypename() ISimpletypenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpletypenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpletypenameContext)
}

func (s *SingletypeContext) QM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserQM, 0)
}

func (s *SingletypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingletypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SingletypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSingletype(s)
	}
}

func (s *SingletypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSingletype(s)
	}
}




func (p *XPath31Parser) Singletype() (localctx ISingletypeContext) {
	localctx = NewSingletypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, XPath31ParserRULE_singletype)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Simpletypename()
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserQM {
		{
			p.SetState(703)
			p.Match(XPath31ParserQM)
		}

	}



	return localctx
}


// ITypedeclarationContext is an interface to support dynamic dispatch.
type ITypedeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedeclarationContext differentiates from other interfaces.
	IsTypedeclarationContext()
}

type TypedeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedeclarationContext() *TypedeclarationContext {
	var p = new(TypedeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_typedeclaration
	return p
}

func (*TypedeclarationContext) IsTypedeclarationContext() {}

func NewTypedeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedeclarationContext {
	var p = new(TypedeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_typedeclaration

	return p
}

func (s *TypedeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedeclarationContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AS, 0)
}

func (s *TypedeclarationContext) Sequencetype() ISequencetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequencetypeContext)
}

func (s *TypedeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypedeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterTypedeclaration(s)
	}
}

func (s *TypedeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitTypedeclaration(s)
	}
}




func (p *XPath31Parser) Typedeclaration() (localctx ITypedeclarationContext) {
	localctx = NewTypedeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, XPath31ParserRULE_typedeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(XPath31ParserKW_AS)
	}
	{
		p.SetState(707)
		p.Sequencetype()
	}



	return localctx
}


// ISequencetypeContext is an interface to support dynamic dispatch.
type ISequencetypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequencetypeContext differentiates from other interfaces.
	IsSequencetypeContext()
}

type SequencetypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequencetypeContext() *SequencetypeContext {
	var p = new(SequencetypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_sequencetype
	return p
}

func (*SequencetypeContext) IsSequencetypeContext() {}

func NewSequencetypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequencetypeContext {
	var p = new(SequencetypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_sequencetype

	return p
}

func (s *SequencetypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SequencetypeContext) KW_EMPTY_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EMPTY_SEQUENCE, 0)
}

func (s *SequencetypeContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *SequencetypeContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *SequencetypeContext) Itemtype() IItemtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItemtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IItemtypeContext)
}

func (s *SequencetypeContext) Occurrenceindicator() IOccurrenceindicatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOccurrenceindicatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOccurrenceindicatorContext)
}

func (s *SequencetypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequencetypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SequencetypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSequencetype(s)
	}
}

func (s *SequencetypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSequencetype(s)
	}
}




func (p *XPath31Parser) Sequencetype() (localctx ISequencetypeContext) {
	localctx = NewSequencetypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, XPath31ParserRULE_sequencetype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(709)
			p.Match(XPath31ParserKW_EMPTY_SEQUENCE)
		}
		{
			p.SetState(710)
			p.Match(XPath31ParserOP)
		}
		{
			p.SetState(711)
			p.Match(XPath31ParserCP)
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.Itemtype()
		}
		p.SetState(714)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(713)
				p.Occurrenceindicator()
			}


		}


	}


	return localctx
}


// IOccurrenceindicatorContext is an interface to support dynamic dispatch.
type IOccurrenceindicatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOccurrenceindicatorContext differentiates from other interfaces.
	IsOccurrenceindicatorContext()
}

type OccurrenceindicatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOccurrenceindicatorContext() *OccurrenceindicatorContext {
	var p = new(OccurrenceindicatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_occurrenceindicator
	return p
}

func (*OccurrenceindicatorContext) IsOccurrenceindicatorContext() {}

func NewOccurrenceindicatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OccurrenceindicatorContext {
	var p = new(OccurrenceindicatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_occurrenceindicator

	return p
}

func (s *OccurrenceindicatorContext) GetParser() antlr.Parser { return s.parser }

func (s *OccurrenceindicatorContext) QM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserQM, 0)
}

func (s *OccurrenceindicatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *OccurrenceindicatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserPLUS, 0)
}

func (s *OccurrenceindicatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OccurrenceindicatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OccurrenceindicatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterOccurrenceindicator(s)
	}
}

func (s *OccurrenceindicatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitOccurrenceindicator(s)
	}
}




func (p *XPath31Parser) Occurrenceindicator() (localctx IOccurrenceindicatorContext) {
	localctx = NewOccurrenceindicatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, XPath31ParserRULE_occurrenceindicator)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 28)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 28))) & ((1 << (XPath31ParserPLUS - 28)) | (1 << (XPath31ParserQM - 28)) | (1 << (XPath31ParserSTAR - 28)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IItemtypeContext is an interface to support dynamic dispatch.
type IItemtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsItemtypeContext differentiates from other interfaces.
	IsItemtypeContext()
}

type ItemtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyItemtypeContext() *ItemtypeContext {
	var p = new(ItemtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_itemtype
	return p
}

func (*ItemtypeContext) IsItemtypeContext() {}

func NewItemtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ItemtypeContext {
	var p = new(ItemtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_itemtype

	return p
}

func (s *ItemtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ItemtypeContext) Kindtest() IKindtestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKindtestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKindtestContext)
}

func (s *ItemtypeContext) KW_ITEM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ITEM, 0)
}

func (s *ItemtypeContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *ItemtypeContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *ItemtypeContext) Functiontest() IFunctiontestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctiontestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctiontestContext)
}

func (s *ItemtypeContext) Maptest() IMaptestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMaptestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMaptestContext)
}

func (s *ItemtypeContext) Arraytest() IArraytestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArraytestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArraytestContext)
}

func (s *ItemtypeContext) Atomicoruniontype() IAtomicoruniontypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicoruniontypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicoruniontypeContext)
}

func (s *ItemtypeContext) Parenthesizeditemtype() IParenthesizeditemtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesizeditemtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesizeditemtypeContext)
}

func (s *ItemtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ItemtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ItemtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterItemtype(s)
	}
}

func (s *ItemtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitItemtype(s)
	}
}




func (p *XPath31Parser) Itemtype() (localctx IItemtypeContext) {
	localctx = NewItemtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, XPath31ParserRULE_itemtype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(720)
			p.Kindtest()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(721)
			p.Match(XPath31ParserKW_ITEM)
		}
		{
			p.SetState(722)
			p.Match(XPath31ParserOP)
		}
		{
			p.SetState(723)
			p.Match(XPath31ParserCP)
		}



	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(724)
			p.Functiontest()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(725)
			p.Maptest()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(726)
			p.Arraytest()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(727)
			p.Atomicoruniontype()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(728)
			p.Parenthesizeditemtype()
		}

	}


	return localctx
}


// IAtomicoruniontypeContext is an interface to support dynamic dispatch.
type IAtomicoruniontypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomicoruniontypeContext differentiates from other interfaces.
	IsAtomicoruniontypeContext()
}

type AtomicoruniontypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomicoruniontypeContext() *AtomicoruniontypeContext {
	var p = new(AtomicoruniontypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_atomicoruniontype
	return p
}

func (*AtomicoruniontypeContext) IsAtomicoruniontypeContext() {}

func NewAtomicoruniontypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomicoruniontypeContext {
	var p = new(AtomicoruniontypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_atomicoruniontype

	return p
}

func (s *AtomicoruniontypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomicoruniontypeContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *AtomicoruniontypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomicoruniontypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AtomicoruniontypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAtomicoruniontype(s)
	}
}

func (s *AtomicoruniontypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAtomicoruniontype(s)
	}
}




func (p *XPath31Parser) Atomicoruniontype() (localctx IAtomicoruniontypeContext) {
	localctx = NewAtomicoruniontypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, XPath31ParserRULE_atomicoruniontype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(731)
		p.Eqname()
	}



	return localctx
}


// IKindtestContext is an interface to support dynamic dispatch.
type IKindtestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKindtestContext differentiates from other interfaces.
	IsKindtestContext()
}

type KindtestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKindtestContext() *KindtestContext {
	var p = new(KindtestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_kindtest
	return p
}

func (*KindtestContext) IsKindtestContext() {}

func NewKindtestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KindtestContext {
	var p = new(KindtestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_kindtest

	return p
}

func (s *KindtestContext) GetParser() antlr.Parser { return s.parser }

func (s *KindtestContext) Documenttest() IDocumenttestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDocumenttestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDocumenttestContext)
}

func (s *KindtestContext) Elementtest() IElementtestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementtestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementtestContext)
}

func (s *KindtestContext) Attributetest() IAttributetestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributetestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributetestContext)
}

func (s *KindtestContext) Schemaelementtest() ISchemaelementtestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaelementtestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaelementtestContext)
}

func (s *KindtestContext) Schemaattributetest() ISchemaattributetestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaattributetestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaattributetestContext)
}

func (s *KindtestContext) Pitest() IPitestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPitestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPitestContext)
}

func (s *KindtestContext) Commenttest() ICommenttestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommenttestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommenttestContext)
}

func (s *KindtestContext) Texttest() ITexttestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITexttestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITexttestContext)
}

func (s *KindtestContext) Namespacenodetest() INamespacenodetestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespacenodetestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespacenodetestContext)
}

func (s *KindtestContext) Anykindtest() IAnykindtestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnykindtestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnykindtestContext)
}

func (s *KindtestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KindtestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KindtestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterKindtest(s)
	}
}

func (s *KindtestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitKindtest(s)
	}
}




func (p *XPath31Parser) Kindtest() (localctx IKindtestContext) {
	localctx = NewKindtestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, XPath31ParserRULE_kindtest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(743)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_DOCUMENT_NODE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(733)
			p.Documenttest()
		}


	case XPath31ParserKW_ELEMENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(734)
			p.Elementtest()
		}


	case XPath31ParserKW_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(735)
			p.Attributetest()
		}


	case XPath31ParserKW_SCHEMA_ELEMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(736)
			p.Schemaelementtest()
		}


	case XPath31ParserKW_SCHEMA_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(737)
			p.Schemaattributetest()
		}


	case XPath31ParserKW_PROCESSING_INSTRUCTION:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(738)
			p.Pitest()
		}


	case XPath31ParserKW_COMMENT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(739)
			p.Commenttest()
		}


	case XPath31ParserKW_TEXT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(740)
			p.Texttest()
		}


	case XPath31ParserKW_NAMESPACE_NODE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(741)
			p.Namespacenodetest()
		}


	case XPath31ParserKW_NODE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(742)
			p.Anykindtest()
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// IAnykindtestContext is an interface to support dynamic dispatch.
type IAnykindtestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnykindtestContext differentiates from other interfaces.
	IsAnykindtestContext()
}

type AnykindtestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnykindtestContext() *AnykindtestContext {
	var p = new(AnykindtestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_anykindtest
	return p
}

func (*AnykindtestContext) IsAnykindtestContext() {}

func NewAnykindtestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnykindtestContext {
	var p = new(AnykindtestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_anykindtest

	return p
}

func (s *AnykindtestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnykindtestContext) KW_NODE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NODE, 0)
}

func (s *AnykindtestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *AnykindtestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *AnykindtestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnykindtestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnykindtestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAnykindtest(s)
	}
}

func (s *AnykindtestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAnykindtest(s)
	}
}




func (p *XPath31Parser) Anykindtest() (localctx IAnykindtestContext) {
	localctx = NewAnykindtestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, XPath31ParserRULE_anykindtest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Match(XPath31ParserKW_NODE)
	}
	{
		p.SetState(746)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(747)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IDocumenttestContext is an interface to support dynamic dispatch.
type IDocumenttestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDocumenttestContext differentiates from other interfaces.
	IsDocumenttestContext()
}

type DocumenttestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDocumenttestContext() *DocumenttestContext {
	var p = new(DocumenttestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_documenttest
	return p
}

func (*DocumenttestContext) IsDocumenttestContext() {}

func NewDocumenttestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DocumenttestContext {
	var p = new(DocumenttestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_documenttest

	return p
}

func (s *DocumenttestContext) GetParser() antlr.Parser { return s.parser }

func (s *DocumenttestContext) KW_DOCUMENT_NODE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DOCUMENT_NODE, 0)
}

func (s *DocumenttestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *DocumenttestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *DocumenttestContext) Elementtest() IElementtestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementtestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementtestContext)
}

func (s *DocumenttestContext) Schemaelementtest() ISchemaelementtestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISchemaelementtestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISchemaelementtestContext)
}

func (s *DocumenttestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DocumenttestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DocumenttestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterDocumenttest(s)
	}
}

func (s *DocumenttestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitDocumenttest(s)
	}
}




func (p *XPath31Parser) Documenttest() (localctx IDocumenttestContext) {
	localctx = NewDocumenttestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, XPath31ParserRULE_documenttest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Match(XPath31ParserKW_DOCUMENT_NODE)
	}
	{
		p.SetState(750)
		p.Match(XPath31ParserOP)
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_ELEMENT:
		{
			p.SetState(751)
			p.Elementtest()
		}


	case XPath31ParserKW_SCHEMA_ELEMENT:
		{
			p.SetState(752)
			p.Schemaelementtest()
		}


	case XPath31ParserCP:



	default:
	}
	{
		p.SetState(755)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// ITexttestContext is an interface to support dynamic dispatch.
type ITexttestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTexttestContext differentiates from other interfaces.
	IsTexttestContext()
}

type TexttestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTexttestContext() *TexttestContext {
	var p = new(TexttestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_texttest
	return p
}

func (*TexttestContext) IsTexttestContext() {}

func NewTexttestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TexttestContext {
	var p = new(TexttestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_texttest

	return p
}

func (s *TexttestContext) GetParser() antlr.Parser { return s.parser }

func (s *TexttestContext) KW_TEXT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_TEXT, 0)
}

func (s *TexttestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *TexttestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *TexttestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TexttestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TexttestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterTexttest(s)
	}
}

func (s *TexttestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitTexttest(s)
	}
}




func (p *XPath31Parser) Texttest() (localctx ITexttestContext) {
	localctx = NewTexttestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, XPath31ParserRULE_texttest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(XPath31ParserKW_TEXT)
	}
	{
		p.SetState(758)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(759)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// ICommenttestContext is an interface to support dynamic dispatch.
type ICommenttestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommenttestContext differentiates from other interfaces.
	IsCommenttestContext()
}

type CommenttestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommenttestContext() *CommenttestContext {
	var p = new(CommenttestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_commenttest
	return p
}

func (*CommenttestContext) IsCommenttestContext() {}

func NewCommenttestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommenttestContext {
	var p = new(CommenttestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_commenttest

	return p
}

func (s *CommenttestContext) GetParser() antlr.Parser { return s.parser }

func (s *CommenttestContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_COMMENT, 0)
}

func (s *CommenttestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *CommenttestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *CommenttestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommenttestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CommenttestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterCommenttest(s)
	}
}

func (s *CommenttestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitCommenttest(s)
	}
}




func (p *XPath31Parser) Commenttest() (localctx ICommenttestContext) {
	localctx = NewCommenttestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, XPath31ParserRULE_commenttest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Match(XPath31ParserKW_COMMENT)
	}
	{
		p.SetState(762)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(763)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// INamespacenodetestContext is an interface to support dynamic dispatch.
type INamespacenodetestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespacenodetestContext differentiates from other interfaces.
	IsNamespacenodetestContext()
}

type NamespacenodetestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespacenodetestContext() *NamespacenodetestContext {
	var p = new(NamespacenodetestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_namespacenodetest
	return p
}

func (*NamespacenodetestContext) IsNamespacenodetestContext() {}

func NewNamespacenodetestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespacenodetestContext {
	var p = new(NamespacenodetestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_namespacenodetest

	return p
}

func (s *NamespacenodetestContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespacenodetestContext) KW_NAMESPACE_NODE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NAMESPACE_NODE, 0)
}

func (s *NamespacenodetestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *NamespacenodetestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *NamespacenodetestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespacenodetestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NamespacenodetestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterNamespacenodetest(s)
	}
}

func (s *NamespacenodetestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitNamespacenodetest(s)
	}
}




func (p *XPath31Parser) Namespacenodetest() (localctx INamespacenodetestContext) {
	localctx = NewNamespacenodetestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, XPath31ParserRULE_namespacenodetest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.Match(XPath31ParserKW_NAMESPACE_NODE)
	}
	{
		p.SetState(766)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(767)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IPitestContext is an interface to support dynamic dispatch.
type IPitestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPitestContext differentiates from other interfaces.
	IsPitestContext()
}

type PitestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPitestContext() *PitestContext {
	var p = new(PitestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_pitest
	return p
}

func (*PitestContext) IsPitestContext() {}

func NewPitestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PitestContext {
	var p = new(PitestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_pitest

	return p
}

func (s *PitestContext) GetParser() antlr.Parser { return s.parser }

func (s *PitestContext) KW_PROCESSING_INSTRUCTION() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PROCESSING_INSTRUCTION, 0)
}

func (s *PitestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *PitestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *PitestContext) NCName() antlr.TerminalNode {
	return s.GetToken(XPath31ParserNCName, 0)
}

func (s *PitestContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(XPath31ParserStringLiteral, 0)
}

func (s *PitestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PitestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PitestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterPitest(s)
	}
}

func (s *PitestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitPitest(s)
	}
}




func (p *XPath31Parser) Pitest() (localctx IPitestContext) {
	localctx = NewPitestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, XPath31ParserRULE_pitest)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(XPath31ParserKW_PROCESSING_INSTRUCTION)
	}
	{
		p.SetState(770)
		p.Match(XPath31ParserOP)
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if _la == XPath31ParserStringLiteral || _la == XPath31ParserNCName {
		{
			p.SetState(771)
			_la = p.GetTokenStream().LA(1)

			if !(_la == XPath31ParserStringLiteral || _la == XPath31ParserNCName) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(774)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IAttributetestContext is an interface to support dynamic dispatch.
type IAttributetestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributetestContext differentiates from other interfaces.
	IsAttributetestContext()
}

type AttributetestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributetestContext() *AttributetestContext {
	var p = new(AttributetestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_attributetest
	return p
}

func (*AttributetestContext) IsAttributetestContext() {}

func NewAttributetestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributetestContext {
	var p = new(AttributetestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_attributetest

	return p
}

func (s *AttributetestContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributetestContext) KW_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ATTRIBUTE, 0)
}

func (s *AttributetestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *AttributetestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *AttributetestContext) Attribnameorwildcard() IAttribnameorwildcardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribnameorwildcardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribnameorwildcardContext)
}

func (s *AttributetestContext) COMMA() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, 0)
}

func (s *AttributetestContext) Typename() ITypenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypenameContext)
}

func (s *AttributetestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributetestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AttributetestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAttributetest(s)
	}
}

func (s *AttributetestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAttributetest(s)
	}
}




func (p *XPath31Parser) Attributetest() (localctx IAttributetestContext) {
	localctx = NewAttributetestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, XPath31ParserRULE_attributetest)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.Match(XPath31ParserKW_ATTRIBUTE)
	}
	{
		p.SetState(777)
		p.Match(XPath31ParserOP)
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 35)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 35))) & ((1 << (XPath31ParserSTAR - 35)) | (1 << (XPath31ParserKW_ANCESTOR - 35)) | (1 << (XPath31ParserKW_ANCESTOR_OR_SELF - 35)) | (1 << (XPath31ParserKW_AND - 35)) | (1 << (XPath31ParserKW_ARRAY - 35)) | (1 << (XPath31ParserKW_AS - 35)) | (1 << (XPath31ParserKW_ATTRIBUTE - 35)) | (1 << (XPath31ParserKW_CAST - 35)) | (1 << (XPath31ParserKW_CASTABLE - 35)) | (1 << (XPath31ParserKW_CHILD - 35)) | (1 << (XPath31ParserKW_COMMENT - 35)) | (1 << (XPath31ParserKW_DESCENDANT - 35)) | (1 << (XPath31ParserKW_DESCENDANT_OR_SELF - 35)) | (1 << (XPath31ParserKW_DIV - 35)) | (1 << (XPath31ParserKW_DOCUMENT_NODE - 35)) | (1 << (XPath31ParserKW_ELEMENT - 35)) | (1 << (XPath31ParserKW_ELSE - 35)) | (1 << (XPath31ParserKW_EMPTY_SEQUENCE - 35)) | (1 << (XPath31ParserKW_EQ - 35)) | (1 << (XPath31ParserKW_EVERY - 35)) | (1 << (XPath31ParserKW_EXCEPT - 35)) | (1 << (XPath31ParserKW_FOLLOWING - 35)) | (1 << (XPath31ParserKW_FOLLOWING_SIBLING - 35)) | (1 << (XPath31ParserKW_FOR - 35)) | (1 << (XPath31ParserKW_FUNCTION - 35)) | (1 << (XPath31ParserKW_GE - 35)) | (1 << (XPath31ParserKW_GT - 35)) | (1 << (XPath31ParserKW_IDIV - 35)) | (1 << (XPath31ParserKW_IF - 35)) | (1 << (XPath31ParserKW_IN - 35)) | (1 << (XPath31ParserKW_INSTANCE - 35)) | (1 << (XPath31ParserKW_INTERSECT - 35)))) != 0) || ((((_la - 67)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 67))) & ((1 << (XPath31ParserKW_IS - 67)) | (1 << (XPath31ParserKW_ITEM - 67)) | (1 << (XPath31ParserKW_LE - 67)) | (1 << (XPath31ParserKW_LET - 67)) | (1 << (XPath31ParserKW_LT - 67)) | (1 << (XPath31ParserKW_MAP - 67)) | (1 << (XPath31ParserKW_MOD - 67)) | (1 << (XPath31ParserKW_NAMESPACE - 67)) | (1 << (XPath31ParserKW_NAMESPACE_NODE - 67)) | (1 << (XPath31ParserKW_NE - 67)) | (1 << (XPath31ParserKW_NODE - 67)) | (1 << (XPath31ParserKW_OF - 67)) | (1 << (XPath31ParserKW_OR - 67)) | (1 << (XPath31ParserKW_PARENT - 67)) | (1 << (XPath31ParserKW_PRECEDING - 67)) | (1 << (XPath31ParserKW_PRECEDING_SIBLING - 67)) | (1 << (XPath31ParserKW_PROCESSING_INSTRUCTION - 67)) | (1 << (XPath31ParserKW_RETURN - 67)) | (1 << (XPath31ParserKW_SATISFIES - 67)) | (1 << (XPath31ParserKW_SCHEMA_ATTRIBUTE - 67)) | (1 << (XPath31ParserKW_SCHEMA_ELEMENT - 67)) | (1 << (XPath31ParserKW_SELF - 67)) | (1 << (XPath31ParserKW_SOME - 67)) | (1 << (XPath31ParserKW_TEXT - 67)) | (1 << (XPath31ParserKW_THEN - 67)) | (1 << (XPath31ParserKW_TREAT - 67)) | (1 << (XPath31ParserKW_UNION - 67)))) != 0) || _la == XPath31ParserURIQualifiedName || _la == XPath31ParserQName {
		{
			p.SetState(778)
			p.Attribnameorwildcard()
		}
		p.SetState(781)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == XPath31ParserCOMMA {
			{
				p.SetState(779)
				p.Match(XPath31ParserCOMMA)
			}
			{
				p.SetState(780)
				p.Typename()
			}

		}

	}
	{
		p.SetState(785)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IAttribnameorwildcardContext is an interface to support dynamic dispatch.
type IAttribnameorwildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribnameorwildcardContext differentiates from other interfaces.
	IsAttribnameorwildcardContext()
}

type AttribnameorwildcardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribnameorwildcardContext() *AttribnameorwildcardContext {
	var p = new(AttribnameorwildcardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_attribnameorwildcard
	return p
}

func (*AttribnameorwildcardContext) IsAttribnameorwildcardContext() {}

func NewAttribnameorwildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttribnameorwildcardContext {
	var p = new(AttribnameorwildcardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_attribnameorwildcard

	return p
}

func (s *AttribnameorwildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *AttribnameorwildcardContext) Attributename() IAttributenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributenameContext)
}

func (s *AttribnameorwildcardContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *AttribnameorwildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttribnameorwildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AttribnameorwildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAttribnameorwildcard(s)
	}
}

func (s *AttribnameorwildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAttribnameorwildcard(s)
	}
}




func (p *XPath31Parser) Attribnameorwildcard() (localctx IAttribnameorwildcardContext) {
	localctx = NewAttribnameorwildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, XPath31ParserRULE_attribnameorwildcard)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(789)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_ANCESTOR, XPath31ParserKW_ANCESTOR_OR_SELF, XPath31ParserKW_AND, XPath31ParserKW_ARRAY, XPath31ParserKW_AS, XPath31ParserKW_ATTRIBUTE, XPath31ParserKW_CAST, XPath31ParserKW_CASTABLE, XPath31ParserKW_CHILD, XPath31ParserKW_COMMENT, XPath31ParserKW_DESCENDANT, XPath31ParserKW_DESCENDANT_OR_SELF, XPath31ParserKW_DIV, XPath31ParserKW_DOCUMENT_NODE, XPath31ParserKW_ELEMENT, XPath31ParserKW_ELSE, XPath31ParserKW_EMPTY_SEQUENCE, XPath31ParserKW_EQ, XPath31ParserKW_EVERY, XPath31ParserKW_EXCEPT, XPath31ParserKW_FOLLOWING, XPath31ParserKW_FOLLOWING_SIBLING, XPath31ParserKW_FOR, XPath31ParserKW_FUNCTION, XPath31ParserKW_GE, XPath31ParserKW_GT, XPath31ParserKW_IDIV, XPath31ParserKW_IF, XPath31ParserKW_IN, XPath31ParserKW_INSTANCE, XPath31ParserKW_INTERSECT, XPath31ParserKW_IS, XPath31ParserKW_ITEM, XPath31ParserKW_LE, XPath31ParserKW_LET, XPath31ParserKW_LT, XPath31ParserKW_MAP, XPath31ParserKW_MOD, XPath31ParserKW_NAMESPACE, XPath31ParserKW_NAMESPACE_NODE, XPath31ParserKW_NE, XPath31ParserKW_NODE, XPath31ParserKW_OF, XPath31ParserKW_OR, XPath31ParserKW_PARENT, XPath31ParserKW_PRECEDING, XPath31ParserKW_PRECEDING_SIBLING, XPath31ParserKW_PROCESSING_INSTRUCTION, XPath31ParserKW_RETURN, XPath31ParserKW_SATISFIES, XPath31ParserKW_SCHEMA_ATTRIBUTE, XPath31ParserKW_SCHEMA_ELEMENT, XPath31ParserKW_SELF, XPath31ParserKW_SOME, XPath31ParserKW_TEXT, XPath31ParserKW_THEN, XPath31ParserKW_TREAT, XPath31ParserKW_UNION, XPath31ParserURIQualifiedName, XPath31ParserQName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(787)
			p.Attributename()
		}


	case XPath31ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(788)
			p.Match(XPath31ParserSTAR)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISchemaattributetestContext is an interface to support dynamic dispatch.
type ISchemaattributetestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaattributetestContext differentiates from other interfaces.
	IsSchemaattributetestContext()
}

type SchemaattributetestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaattributetestContext() *SchemaattributetestContext {
	var p = new(SchemaattributetestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_schemaattributetest
	return p
}

func (*SchemaattributetestContext) IsSchemaattributetestContext() {}

func NewSchemaattributetestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaattributetestContext {
	var p = new(SchemaattributetestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_schemaattributetest

	return p
}

func (s *SchemaattributetestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaattributetestContext) KW_SCHEMA_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SCHEMA_ATTRIBUTE, 0)
}

func (s *SchemaattributetestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *SchemaattributetestContext) Attributedeclaration() IAttributedeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributedeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributedeclarationContext)
}

func (s *SchemaattributetestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *SchemaattributetestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaattributetestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SchemaattributetestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSchemaattributetest(s)
	}
}

func (s *SchemaattributetestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSchemaattributetest(s)
	}
}




func (p *XPath31Parser) Schemaattributetest() (localctx ISchemaattributetestContext) {
	localctx = NewSchemaattributetestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, XPath31ParserRULE_schemaattributetest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.Match(XPath31ParserKW_SCHEMA_ATTRIBUTE)
	}
	{
		p.SetState(792)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(793)
		p.Attributedeclaration()
	}
	{
		p.SetState(794)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IAttributedeclarationContext is an interface to support dynamic dispatch.
type IAttributedeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributedeclarationContext differentiates from other interfaces.
	IsAttributedeclarationContext()
}

type AttributedeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributedeclarationContext() *AttributedeclarationContext {
	var p = new(AttributedeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_attributedeclaration
	return p
}

func (*AttributedeclarationContext) IsAttributedeclarationContext() {}

func NewAttributedeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributedeclarationContext {
	var p = new(AttributedeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_attributedeclaration

	return p
}

func (s *AttributedeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributedeclarationContext) Attributename() IAttributenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributenameContext)
}

func (s *AttributedeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributedeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AttributedeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAttributedeclaration(s)
	}
}

func (s *AttributedeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAttributedeclaration(s)
	}
}




func (p *XPath31Parser) Attributedeclaration() (localctx IAttributedeclarationContext) {
	localctx = NewAttributedeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, XPath31ParserRULE_attributedeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Attributename()
	}



	return localctx
}


// IElementtestContext is an interface to support dynamic dispatch.
type IElementtestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementtestContext differentiates from other interfaces.
	IsElementtestContext()
}

type ElementtestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementtestContext() *ElementtestContext {
	var p = new(ElementtestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_elementtest
	return p
}

func (*ElementtestContext) IsElementtestContext() {}

func NewElementtestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementtestContext {
	var p = new(ElementtestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_elementtest

	return p
}

func (s *ElementtestContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementtestContext) KW_ELEMENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ELEMENT, 0)
}

func (s *ElementtestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *ElementtestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *ElementtestContext) Elementnameorwildcard() IElementnameorwildcardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementnameorwildcardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementnameorwildcardContext)
}

func (s *ElementtestContext) COMMA() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, 0)
}

func (s *ElementtestContext) Typename() ITypenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypenameContext)
}

func (s *ElementtestContext) QM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserQM, 0)
}

func (s *ElementtestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementtestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementtestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterElementtest(s)
	}
}

func (s *ElementtestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitElementtest(s)
	}
}




func (p *XPath31Parser) Elementtest() (localctx IElementtestContext) {
	localctx = NewElementtestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, XPath31ParserRULE_elementtest)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.Match(XPath31ParserKW_ELEMENT)
	}
	{
		p.SetState(799)
		p.Match(XPath31ParserOP)
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 35)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 35))) & ((1 << (XPath31ParserSTAR - 35)) | (1 << (XPath31ParserKW_ANCESTOR - 35)) | (1 << (XPath31ParserKW_ANCESTOR_OR_SELF - 35)) | (1 << (XPath31ParserKW_AND - 35)) | (1 << (XPath31ParserKW_ARRAY - 35)) | (1 << (XPath31ParserKW_AS - 35)) | (1 << (XPath31ParserKW_ATTRIBUTE - 35)) | (1 << (XPath31ParserKW_CAST - 35)) | (1 << (XPath31ParserKW_CASTABLE - 35)) | (1 << (XPath31ParserKW_CHILD - 35)) | (1 << (XPath31ParserKW_COMMENT - 35)) | (1 << (XPath31ParserKW_DESCENDANT - 35)) | (1 << (XPath31ParserKW_DESCENDANT_OR_SELF - 35)) | (1 << (XPath31ParserKW_DIV - 35)) | (1 << (XPath31ParserKW_DOCUMENT_NODE - 35)) | (1 << (XPath31ParserKW_ELEMENT - 35)) | (1 << (XPath31ParserKW_ELSE - 35)) | (1 << (XPath31ParserKW_EMPTY_SEQUENCE - 35)) | (1 << (XPath31ParserKW_EQ - 35)) | (1 << (XPath31ParserKW_EVERY - 35)) | (1 << (XPath31ParserKW_EXCEPT - 35)) | (1 << (XPath31ParserKW_FOLLOWING - 35)) | (1 << (XPath31ParserKW_FOLLOWING_SIBLING - 35)) | (1 << (XPath31ParserKW_FOR - 35)) | (1 << (XPath31ParserKW_FUNCTION - 35)) | (1 << (XPath31ParserKW_GE - 35)) | (1 << (XPath31ParserKW_GT - 35)) | (1 << (XPath31ParserKW_IDIV - 35)) | (1 << (XPath31ParserKW_IF - 35)) | (1 << (XPath31ParserKW_IN - 35)) | (1 << (XPath31ParserKW_INSTANCE - 35)) | (1 << (XPath31ParserKW_INTERSECT - 35)))) != 0) || ((((_la - 67)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 67))) & ((1 << (XPath31ParserKW_IS - 67)) | (1 << (XPath31ParserKW_ITEM - 67)) | (1 << (XPath31ParserKW_LE - 67)) | (1 << (XPath31ParserKW_LET - 67)) | (1 << (XPath31ParserKW_LT - 67)) | (1 << (XPath31ParserKW_MAP - 67)) | (1 << (XPath31ParserKW_MOD - 67)) | (1 << (XPath31ParserKW_NAMESPACE - 67)) | (1 << (XPath31ParserKW_NAMESPACE_NODE - 67)) | (1 << (XPath31ParserKW_NE - 67)) | (1 << (XPath31ParserKW_NODE - 67)) | (1 << (XPath31ParserKW_OF - 67)) | (1 << (XPath31ParserKW_OR - 67)) | (1 << (XPath31ParserKW_PARENT - 67)) | (1 << (XPath31ParserKW_PRECEDING - 67)) | (1 << (XPath31ParserKW_PRECEDING_SIBLING - 67)) | (1 << (XPath31ParserKW_PROCESSING_INSTRUCTION - 67)) | (1 << (XPath31ParserKW_RETURN - 67)) | (1 << (XPath31ParserKW_SATISFIES - 67)) | (1 << (XPath31ParserKW_SCHEMA_ATTRIBUTE - 67)) | (1 << (XPath31ParserKW_SCHEMA_ELEMENT - 67)) | (1 << (XPath31ParserKW_SELF - 67)) | (1 << (XPath31ParserKW_SOME - 67)) | (1 << (XPath31ParserKW_TEXT - 67)) | (1 << (XPath31ParserKW_THEN - 67)) | (1 << (XPath31ParserKW_TREAT - 67)) | (1 << (XPath31ParserKW_UNION - 67)))) != 0) || _la == XPath31ParserURIQualifiedName || _la == XPath31ParserQName {
		{
			p.SetState(800)
			p.Elementnameorwildcard()
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		if _la == XPath31ParserCOMMA {
			{
				p.SetState(801)
				p.Match(XPath31ParserCOMMA)
			}
			{
				p.SetState(802)
				p.Typename()
			}
			p.SetState(804)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)


			if _la == XPath31ParserQM {
				{
					p.SetState(803)
					p.Match(XPath31ParserQM)
				}

			}

		}

	}
	{
		p.SetState(810)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IElementnameorwildcardContext is an interface to support dynamic dispatch.
type IElementnameorwildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementnameorwildcardContext differentiates from other interfaces.
	IsElementnameorwildcardContext()
}

type ElementnameorwildcardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementnameorwildcardContext() *ElementnameorwildcardContext {
	var p = new(ElementnameorwildcardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_elementnameorwildcard
	return p
}

func (*ElementnameorwildcardContext) IsElementnameorwildcardContext() {}

func NewElementnameorwildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementnameorwildcardContext {
	var p = new(ElementnameorwildcardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_elementnameorwildcard

	return p
}

func (s *ElementnameorwildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementnameorwildcardContext) Elementname() IElementnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementnameContext)
}

func (s *ElementnameorwildcardContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *ElementnameorwildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementnameorwildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementnameorwildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterElementnameorwildcard(s)
	}
}

func (s *ElementnameorwildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitElementnameorwildcard(s)
	}
}




func (p *XPath31Parser) Elementnameorwildcard() (localctx IElementnameorwildcardContext) {
	localctx = NewElementnameorwildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, XPath31ParserRULE_elementnameorwildcard)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(814)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case XPath31ParserKW_ANCESTOR, XPath31ParserKW_ANCESTOR_OR_SELF, XPath31ParserKW_AND, XPath31ParserKW_ARRAY, XPath31ParserKW_AS, XPath31ParserKW_ATTRIBUTE, XPath31ParserKW_CAST, XPath31ParserKW_CASTABLE, XPath31ParserKW_CHILD, XPath31ParserKW_COMMENT, XPath31ParserKW_DESCENDANT, XPath31ParserKW_DESCENDANT_OR_SELF, XPath31ParserKW_DIV, XPath31ParserKW_DOCUMENT_NODE, XPath31ParserKW_ELEMENT, XPath31ParserKW_ELSE, XPath31ParserKW_EMPTY_SEQUENCE, XPath31ParserKW_EQ, XPath31ParserKW_EVERY, XPath31ParserKW_EXCEPT, XPath31ParserKW_FOLLOWING, XPath31ParserKW_FOLLOWING_SIBLING, XPath31ParserKW_FOR, XPath31ParserKW_FUNCTION, XPath31ParserKW_GE, XPath31ParserKW_GT, XPath31ParserKW_IDIV, XPath31ParserKW_IF, XPath31ParserKW_IN, XPath31ParserKW_INSTANCE, XPath31ParserKW_INTERSECT, XPath31ParserKW_IS, XPath31ParserKW_ITEM, XPath31ParserKW_LE, XPath31ParserKW_LET, XPath31ParserKW_LT, XPath31ParserKW_MAP, XPath31ParserKW_MOD, XPath31ParserKW_NAMESPACE, XPath31ParserKW_NAMESPACE_NODE, XPath31ParserKW_NE, XPath31ParserKW_NODE, XPath31ParserKW_OF, XPath31ParserKW_OR, XPath31ParserKW_PARENT, XPath31ParserKW_PRECEDING, XPath31ParserKW_PRECEDING_SIBLING, XPath31ParserKW_PROCESSING_INSTRUCTION, XPath31ParserKW_RETURN, XPath31ParserKW_SATISFIES, XPath31ParserKW_SCHEMA_ATTRIBUTE, XPath31ParserKW_SCHEMA_ELEMENT, XPath31ParserKW_SELF, XPath31ParserKW_SOME, XPath31ParserKW_TEXT, XPath31ParserKW_THEN, XPath31ParserKW_TREAT, XPath31ParserKW_UNION, XPath31ParserURIQualifiedName, XPath31ParserQName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(812)
			p.Elementname()
		}


	case XPath31ParserSTAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(813)
			p.Match(XPath31ParserSTAR)
		}



	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}


	return localctx
}


// ISchemaelementtestContext is an interface to support dynamic dispatch.
type ISchemaelementtestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSchemaelementtestContext differentiates from other interfaces.
	IsSchemaelementtestContext()
}

type SchemaelementtestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaelementtestContext() *SchemaelementtestContext {
	var p = new(SchemaelementtestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_schemaelementtest
	return p
}

func (*SchemaelementtestContext) IsSchemaelementtestContext() {}

func NewSchemaelementtestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaelementtestContext {
	var p = new(SchemaelementtestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_schemaelementtest

	return p
}

func (s *SchemaelementtestContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaelementtestContext) KW_SCHEMA_ELEMENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SCHEMA_ELEMENT, 0)
}

func (s *SchemaelementtestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *SchemaelementtestContext) Elementdeclaration() IElementdeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementdeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementdeclarationContext)
}

func (s *SchemaelementtestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *SchemaelementtestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaelementtestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SchemaelementtestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSchemaelementtest(s)
	}
}

func (s *SchemaelementtestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSchemaelementtest(s)
	}
}




func (p *XPath31Parser) Schemaelementtest() (localctx ISchemaelementtestContext) {
	localctx = NewSchemaelementtestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, XPath31ParserRULE_schemaelementtest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(XPath31ParserKW_SCHEMA_ELEMENT)
	}
	{
		p.SetState(817)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(818)
		p.Elementdeclaration()
	}
	{
		p.SetState(819)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IElementdeclarationContext is an interface to support dynamic dispatch.
type IElementdeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementdeclarationContext differentiates from other interfaces.
	IsElementdeclarationContext()
}

type ElementdeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementdeclarationContext() *ElementdeclarationContext {
	var p = new(ElementdeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_elementdeclaration
	return p
}

func (*ElementdeclarationContext) IsElementdeclarationContext() {}

func NewElementdeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementdeclarationContext {
	var p = new(ElementdeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_elementdeclaration

	return p
}

func (s *ElementdeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementdeclarationContext) Elementname() IElementnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementnameContext)
}

func (s *ElementdeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementdeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementdeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterElementdeclaration(s)
	}
}

func (s *ElementdeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitElementdeclaration(s)
	}
}




func (p *XPath31Parser) Elementdeclaration() (localctx IElementdeclarationContext) {
	localctx = NewElementdeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, XPath31ParserRULE_elementdeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.Elementname()
	}



	return localctx
}


// IAttributenameContext is an interface to support dynamic dispatch.
type IAttributenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributenameContext differentiates from other interfaces.
	IsAttributenameContext()
}

type AttributenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributenameContext() *AttributenameContext {
	var p = new(AttributenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_attributename
	return p
}

func (*AttributenameContext) IsAttributenameContext() {}

func NewAttributenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributenameContext {
	var p = new(AttributenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_attributename

	return p
}

func (s *AttributenameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributenameContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *AttributenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AttributenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAttributename(s)
	}
}

func (s *AttributenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAttributename(s)
	}
}




func (p *XPath31Parser) Attributename() (localctx IAttributenameContext) {
	localctx = NewAttributenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, XPath31ParserRULE_attributename)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Eqname()
	}



	return localctx
}


// IElementnameContext is an interface to support dynamic dispatch.
type IElementnameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementnameContext differentiates from other interfaces.
	IsElementnameContext()
}

type ElementnameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementnameContext() *ElementnameContext {
	var p = new(ElementnameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_elementname
	return p
}

func (*ElementnameContext) IsElementnameContext() {}

func NewElementnameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementnameContext {
	var p = new(ElementnameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_elementname

	return p
}

func (s *ElementnameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementnameContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *ElementnameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementnameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ElementnameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterElementname(s)
	}
}

func (s *ElementnameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitElementname(s)
	}
}




func (p *XPath31Parser) Elementname() (localctx IElementnameContext) {
	localctx = NewElementnameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, XPath31ParserRULE_elementname)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Eqname()
	}



	return localctx
}


// ISimpletypenameContext is an interface to support dynamic dispatch.
type ISimpletypenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpletypenameContext differentiates from other interfaces.
	IsSimpletypenameContext()
}

type SimpletypenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpletypenameContext() *SimpletypenameContext {
	var p = new(SimpletypenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_simpletypename
	return p
}

func (*SimpletypenameContext) IsSimpletypenameContext() {}

func NewSimpletypenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpletypenameContext {
	var p = new(SimpletypenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_simpletypename

	return p
}

func (s *SimpletypenameContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpletypenameContext) Typename() ITypenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypenameContext)
}

func (s *SimpletypenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpletypenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SimpletypenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterSimpletypename(s)
	}
}

func (s *SimpletypenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitSimpletypename(s)
	}
}




func (p *XPath31Parser) Simpletypename() (localctx ISimpletypenameContext) {
	localctx = NewSimpletypenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, XPath31ParserRULE_simpletypename)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Typename()
	}



	return localctx
}


// ITypenameContext is an interface to support dynamic dispatch.
type ITypenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypenameContext differentiates from other interfaces.
	IsTypenameContext()
}

type TypenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypenameContext() *TypenameContext {
	var p = new(TypenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_typename
	return p
}

func (*TypenameContext) IsTypenameContext() {}

func NewTypenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypenameContext {
	var p = new(TypenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_typename

	return p
}

func (s *TypenameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypenameContext) Eqname() IEqnameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEqnameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEqnameContext)
}

func (s *TypenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterTypename(s)
	}
}

func (s *TypenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitTypename(s)
	}
}




func (p *XPath31Parser) Typename() (localctx ITypenameContext) {
	localctx = NewTypenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, XPath31ParserRULE_typename)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		p.Eqname()
	}



	return localctx
}


// IFunctiontestContext is an interface to support dynamic dispatch.
type IFunctiontestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctiontestContext differentiates from other interfaces.
	IsFunctiontestContext()
}

type FunctiontestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctiontestContext() *FunctiontestContext {
	var p = new(FunctiontestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_functiontest
	return p
}

func (*FunctiontestContext) IsFunctiontestContext() {}

func NewFunctiontestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctiontestContext {
	var p = new(FunctiontestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_functiontest

	return p
}

func (s *FunctiontestContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctiontestContext) Anyfunctiontest() IAnyfunctiontestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnyfunctiontestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnyfunctiontestContext)
}

func (s *FunctiontestContext) Typedfunctiontest() ITypedfunctiontestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedfunctiontestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedfunctiontestContext)
}

func (s *FunctiontestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctiontestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctiontestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterFunctiontest(s)
	}
}

func (s *FunctiontestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitFunctiontest(s)
	}
}




func (p *XPath31Parser) Functiontest() (localctx IFunctiontestContext) {
	localctx = NewFunctiontestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, XPath31ParserRULE_functiontest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(831)
			p.Anyfunctiontest()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(832)
			p.Typedfunctiontest()
		}

	}


	return localctx
}


// IAnyfunctiontestContext is an interface to support dynamic dispatch.
type IAnyfunctiontestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnyfunctiontestContext differentiates from other interfaces.
	IsAnyfunctiontestContext()
}

type AnyfunctiontestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyfunctiontestContext() *AnyfunctiontestContext {
	var p = new(AnyfunctiontestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_anyfunctiontest
	return p
}

func (*AnyfunctiontestContext) IsAnyfunctiontestContext() {}

func NewAnyfunctiontestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyfunctiontestContext {
	var p = new(AnyfunctiontestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_anyfunctiontest

	return p
}

func (s *AnyfunctiontestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyfunctiontestContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FUNCTION, 0)
}

func (s *AnyfunctiontestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *AnyfunctiontestContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *AnyfunctiontestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *AnyfunctiontestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyfunctiontestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnyfunctiontestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAnyfunctiontest(s)
	}
}

func (s *AnyfunctiontestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAnyfunctiontest(s)
	}
}




func (p *XPath31Parser) Anyfunctiontest() (localctx IAnyfunctiontestContext) {
	localctx = NewAnyfunctiontestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, XPath31ParserRULE_anyfunctiontest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(835)
		p.Match(XPath31ParserKW_FUNCTION)
	}
	{
		p.SetState(836)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(837)
		p.Match(XPath31ParserSTAR)
	}
	{
		p.SetState(838)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// ITypedfunctiontestContext is an interface to support dynamic dispatch.
type ITypedfunctiontestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedfunctiontestContext differentiates from other interfaces.
	IsTypedfunctiontestContext()
}

type TypedfunctiontestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedfunctiontestContext() *TypedfunctiontestContext {
	var p = new(TypedfunctiontestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_typedfunctiontest
	return p
}

func (*TypedfunctiontestContext) IsTypedfunctiontestContext() {}

func NewTypedfunctiontestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedfunctiontestContext {
	var p = new(TypedfunctiontestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_typedfunctiontest

	return p
}

func (s *TypedfunctiontestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedfunctiontestContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FUNCTION, 0)
}

func (s *TypedfunctiontestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *TypedfunctiontestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *TypedfunctiontestContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AS, 0)
}

func (s *TypedfunctiontestContext) AllSequencetype() []ISequencetypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem())
	var tst = make([]ISequencetypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISequencetypeContext)
		}
	}

	return tst
}

func (s *TypedfunctiontestContext) Sequencetype(i int) ISequencetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISequencetypeContext)
}

func (s *TypedfunctiontestContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserCOMMA)
}

func (s *TypedfunctiontestContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, i)
}

func (s *TypedfunctiontestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedfunctiontestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypedfunctiontestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterTypedfunctiontest(s)
	}
}

func (s *TypedfunctiontestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitTypedfunctiontest(s)
	}
}




func (p *XPath31Parser) Typedfunctiontest() (localctx ITypedfunctiontestContext) {
	localctx = NewTypedfunctiontestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, XPath31ParserRULE_typedfunctiontest)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(840)
		p.Match(XPath31ParserKW_FUNCTION)
	}
	{
		p.SetState(841)
		p.Match(XPath31ParserOP)
	}
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)


	if ((((_la - 26)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 26))) & ((1 << (XPath31ParserOP - 26)) | (1 << (XPath31ParserKW_ANCESTOR - 26)) | (1 << (XPath31ParserKW_ANCESTOR_OR_SELF - 26)) | (1 << (XPath31ParserKW_AND - 26)) | (1 << (XPath31ParserKW_ARRAY - 26)) | (1 << (XPath31ParserKW_AS - 26)) | (1 << (XPath31ParserKW_ATTRIBUTE - 26)) | (1 << (XPath31ParserKW_CAST - 26)) | (1 << (XPath31ParserKW_CASTABLE - 26)) | (1 << (XPath31ParserKW_CHILD - 26)) | (1 << (XPath31ParserKW_COMMENT - 26)) | (1 << (XPath31ParserKW_DESCENDANT - 26)) | (1 << (XPath31ParserKW_DESCENDANT_OR_SELF - 26)) | (1 << (XPath31ParserKW_DIV - 26)) | (1 << (XPath31ParserKW_DOCUMENT_NODE - 26)) | (1 << (XPath31ParserKW_ELEMENT - 26)) | (1 << (XPath31ParserKW_ELSE - 26)) | (1 << (XPath31ParserKW_EMPTY_SEQUENCE - 26)) | (1 << (XPath31ParserKW_EQ - 26)) | (1 << (XPath31ParserKW_EVERY - 26)) | (1 << (XPath31ParserKW_EXCEPT - 26)) | (1 << (XPath31ParserKW_FOLLOWING - 26)) | (1 << (XPath31ParserKW_FOLLOWING_SIBLING - 26)))) != 0) || ((((_la - 58)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 58))) & ((1 << (XPath31ParserKW_FOR - 58)) | (1 << (XPath31ParserKW_FUNCTION - 58)) | (1 << (XPath31ParserKW_GE - 58)) | (1 << (XPath31ParserKW_GT - 58)) | (1 << (XPath31ParserKW_IDIV - 58)) | (1 << (XPath31ParserKW_IF - 58)) | (1 << (XPath31ParserKW_IN - 58)) | (1 << (XPath31ParserKW_INSTANCE - 58)) | (1 << (XPath31ParserKW_INTERSECT - 58)) | (1 << (XPath31ParserKW_IS - 58)) | (1 << (XPath31ParserKW_ITEM - 58)) | (1 << (XPath31ParserKW_LE - 58)) | (1 << (XPath31ParserKW_LET - 58)) | (1 << (XPath31ParserKW_LT - 58)) | (1 << (XPath31ParserKW_MAP - 58)) | (1 << (XPath31ParserKW_MOD - 58)) | (1 << (XPath31ParserKW_NAMESPACE - 58)) | (1 << (XPath31ParserKW_NAMESPACE_NODE - 58)) | (1 << (XPath31ParserKW_NE - 58)) | (1 << (XPath31ParserKW_NODE - 58)) | (1 << (XPath31ParserKW_OF - 58)) | (1 << (XPath31ParserKW_OR - 58)) | (1 << (XPath31ParserKW_PARENT - 58)) | (1 << (XPath31ParserKW_PRECEDING - 58)) | (1 << (XPath31ParserKW_PRECEDING_SIBLING - 58)) | (1 << (XPath31ParserKW_PROCESSING_INSTRUCTION - 58)) | (1 << (XPath31ParserKW_RETURN - 58)) | (1 << (XPath31ParserKW_SATISFIES - 58)) | (1 << (XPath31ParserKW_SCHEMA_ATTRIBUTE - 58)) | (1 << (XPath31ParserKW_SCHEMA_ELEMENT - 58)) | (1 << (XPath31ParserKW_SELF - 58)) | (1 << (XPath31ParserKW_SOME - 58)))) != 0) || ((((_la - 90)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 90))) & ((1 << (XPath31ParserKW_TEXT - 90)) | (1 << (XPath31ParserKW_THEN - 90)) | (1 << (XPath31ParserKW_TREAT - 90)) | (1 << (XPath31ParserKW_UNION - 90)) | (1 << (XPath31ParserURIQualifiedName - 90)) | (1 << (XPath31ParserQName - 90)))) != 0) {
		{
			p.SetState(842)
			p.Sequencetype()
		}
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)


		for _la == XPath31ParserCOMMA {
			{
				p.SetState(843)
				p.Match(XPath31ParserCOMMA)
			}
			{
				p.SetState(844)
				p.Sequencetype()
			}


			p.SetState(849)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(852)
		p.Match(XPath31ParserCP)
	}
	{
		p.SetState(853)
		p.Match(XPath31ParserKW_AS)
	}
	{
		p.SetState(854)
		p.Sequencetype()
	}



	return localctx
}


// IMaptestContext is an interface to support dynamic dispatch.
type IMaptestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMaptestContext differentiates from other interfaces.
	IsMaptestContext()
}

type MaptestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaptestContext() *MaptestContext {
	var p = new(MaptestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_maptest
	return p
}

func (*MaptestContext) IsMaptestContext() {}

func NewMaptestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaptestContext {
	var p = new(MaptestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_maptest

	return p
}

func (s *MaptestContext) GetParser() antlr.Parser { return s.parser }

func (s *MaptestContext) Anymaptest() IAnymaptestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnymaptestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnymaptestContext)
}

func (s *MaptestContext) Typedmaptest() ITypedmaptestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedmaptestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedmaptestContext)
}

func (s *MaptestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaptestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *MaptestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterMaptest(s)
	}
}

func (s *MaptestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitMaptest(s)
	}
}




func (p *XPath31Parser) Maptest() (localctx IMaptestContext) {
	localctx = NewMaptestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, XPath31ParserRULE_maptest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(858)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(856)
			p.Anymaptest()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(857)
			p.Typedmaptest()
		}

	}


	return localctx
}


// IAnymaptestContext is an interface to support dynamic dispatch.
type IAnymaptestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnymaptestContext differentiates from other interfaces.
	IsAnymaptestContext()
}

type AnymaptestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnymaptestContext() *AnymaptestContext {
	var p = new(AnymaptestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_anymaptest
	return p
}

func (*AnymaptestContext) IsAnymaptestContext() {}

func NewAnymaptestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnymaptestContext {
	var p = new(AnymaptestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_anymaptest

	return p
}

func (s *AnymaptestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnymaptestContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_MAP, 0)
}

func (s *AnymaptestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *AnymaptestContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *AnymaptestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *AnymaptestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnymaptestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnymaptestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAnymaptest(s)
	}
}

func (s *AnymaptestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAnymaptest(s)
	}
}




func (p *XPath31Parser) Anymaptest() (localctx IAnymaptestContext) {
	localctx = NewAnymaptestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, XPath31ParserRULE_anymaptest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.Match(XPath31ParserKW_MAP)
	}
	{
		p.SetState(861)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(862)
		p.Match(XPath31ParserSTAR)
	}
	{
		p.SetState(863)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// ITypedmaptestContext is an interface to support dynamic dispatch.
type ITypedmaptestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedmaptestContext differentiates from other interfaces.
	IsTypedmaptestContext()
}

type TypedmaptestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedmaptestContext() *TypedmaptestContext {
	var p = new(TypedmaptestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_typedmaptest
	return p
}

func (*TypedmaptestContext) IsTypedmaptestContext() {}

func NewTypedmaptestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedmaptestContext {
	var p = new(TypedmaptestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_typedmaptest

	return p
}

func (s *TypedmaptestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedmaptestContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_MAP, 0)
}

func (s *TypedmaptestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *TypedmaptestContext) Atomicoruniontype() IAtomicoruniontypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomicoruniontypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomicoruniontypeContext)
}

func (s *TypedmaptestContext) COMMA() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCOMMA, 0)
}

func (s *TypedmaptestContext) Sequencetype() ISequencetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequencetypeContext)
}

func (s *TypedmaptestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *TypedmaptestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedmaptestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypedmaptestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterTypedmaptest(s)
	}
}

func (s *TypedmaptestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitTypedmaptest(s)
	}
}




func (p *XPath31Parser) Typedmaptest() (localctx ITypedmaptestContext) {
	localctx = NewTypedmaptestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, XPath31ParserRULE_typedmaptest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(865)
		p.Match(XPath31ParserKW_MAP)
	}
	{
		p.SetState(866)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(867)
		p.Atomicoruniontype()
	}
	{
		p.SetState(868)
		p.Match(XPath31ParserCOMMA)
	}
	{
		p.SetState(869)
		p.Sequencetype()
	}
	{
		p.SetState(870)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IArraytestContext is an interface to support dynamic dispatch.
type IArraytestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArraytestContext differentiates from other interfaces.
	IsArraytestContext()
}

type ArraytestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArraytestContext() *ArraytestContext {
	var p = new(ArraytestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_arraytest
	return p
}

func (*ArraytestContext) IsArraytestContext() {}

func NewArraytestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArraytestContext {
	var p = new(ArraytestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_arraytest

	return p
}

func (s *ArraytestContext) GetParser() antlr.Parser { return s.parser }

func (s *ArraytestContext) Anyarraytest() IAnyarraytestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnyarraytestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnyarraytestContext)
}

func (s *ArraytestContext) Typedarraytest() ITypedarraytestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedarraytestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedarraytestContext)
}

func (s *ArraytestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraytestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ArraytestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterArraytest(s)
	}
}

func (s *ArraytestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitArraytest(s)
	}
}




func (p *XPath31Parser) Arraytest() (localctx IArraytestContext) {
	localctx = NewArraytestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, XPath31ParserRULE_arraytest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(872)
			p.Anyarraytest()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(873)
			p.Typedarraytest()
		}

	}


	return localctx
}


// IAnyarraytestContext is an interface to support dynamic dispatch.
type IAnyarraytestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnyarraytestContext differentiates from other interfaces.
	IsAnyarraytestContext()
}

type AnyarraytestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyarraytestContext() *AnyarraytestContext {
	var p = new(AnyarraytestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_anyarraytest
	return p
}

func (*AnyarraytestContext) IsAnyarraytestContext() {}

func NewAnyarraytestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyarraytestContext {
	var p = new(AnyarraytestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_anyarraytest

	return p
}

func (s *AnyarraytestContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyarraytestContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ARRAY, 0)
}

func (s *AnyarraytestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *AnyarraytestContext) STAR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserSTAR, 0)
}

func (s *AnyarraytestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *AnyarraytestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyarraytestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AnyarraytestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAnyarraytest(s)
	}
}

func (s *AnyarraytestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAnyarraytest(s)
	}
}




func (p *XPath31Parser) Anyarraytest() (localctx IAnyarraytestContext) {
	localctx = NewAnyarraytestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, XPath31ParserRULE_anyarraytest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(876)
		p.Match(XPath31ParserKW_ARRAY)
	}
	{
		p.SetState(877)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(878)
		p.Match(XPath31ParserSTAR)
	}
	{
		p.SetState(879)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// ITypedarraytestContext is an interface to support dynamic dispatch.
type ITypedarraytestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedarraytestContext differentiates from other interfaces.
	IsTypedarraytestContext()
}

type TypedarraytestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedarraytestContext() *TypedarraytestContext {
	var p = new(TypedarraytestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_typedarraytest
	return p
}

func (*TypedarraytestContext) IsTypedarraytestContext() {}

func NewTypedarraytestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedarraytestContext {
	var p = new(TypedarraytestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_typedarraytest

	return p
}

func (s *TypedarraytestContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedarraytestContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ARRAY, 0)
}

func (s *TypedarraytestContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *TypedarraytestContext) Sequencetype() ISequencetypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequencetypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequencetypeContext)
}

func (s *TypedarraytestContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *TypedarraytestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedarraytestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypedarraytestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterTypedarraytest(s)
	}
}

func (s *TypedarraytestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitTypedarraytest(s)
	}
}




func (p *XPath31Parser) Typedarraytest() (localctx ITypedarraytestContext) {
	localctx = NewTypedarraytestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, XPath31ParserRULE_typedarraytest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.Match(XPath31ParserKW_ARRAY)
	}
	{
		p.SetState(882)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(883)
		p.Sequencetype()
	}
	{
		p.SetState(884)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IParenthesizeditemtypeContext is an interface to support dynamic dispatch.
type IParenthesizeditemtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesizeditemtypeContext differentiates from other interfaces.
	IsParenthesizeditemtypeContext()
}

type ParenthesizeditemtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesizeditemtypeContext() *ParenthesizeditemtypeContext {
	var p = new(ParenthesizeditemtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_parenthesizeditemtype
	return p
}

func (*ParenthesizeditemtypeContext) IsParenthesizeditemtypeContext() {}

func NewParenthesizeditemtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesizeditemtypeContext {
	var p = new(ParenthesizeditemtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_parenthesizeditemtype

	return p
}

func (s *ParenthesizeditemtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesizeditemtypeContext) OP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserOP, 0)
}

func (s *ParenthesizeditemtypeContext) Itemtype() IItemtypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IItemtypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IItemtypeContext)
}

func (s *ParenthesizeditemtypeContext) CP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserCP, 0)
}

func (s *ParenthesizeditemtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizeditemtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParenthesizeditemtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterParenthesizeditemtype(s)
	}
}

func (s *ParenthesizeditemtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitParenthesizeditemtype(s)
	}
}




func (p *XPath31Parser) Parenthesizeditemtype() (localctx IParenthesizeditemtypeContext) {
	localctx = NewParenthesizeditemtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, XPath31ParserRULE_parenthesizeditemtype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(XPath31ParserOP)
	}
	{
		p.SetState(887)
		p.Itemtype()
	}
	{
		p.SetState(888)
		p.Match(XPath31ParserCP)
	}



	return localctx
}


// IEqnameContext is an interface to support dynamic dispatch.
type IEqnameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEqnameContext differentiates from other interfaces.
	IsEqnameContext()
}

type EqnameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqnameContext() *EqnameContext {
	var p = new(EqnameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_eqname
	return p
}

func (*EqnameContext) IsEqnameContext() {}

func NewEqnameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqnameContext {
	var p = new(EqnameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_eqname

	return p
}

func (s *EqnameContext) GetParser() antlr.Parser { return s.parser }

func (s *EqnameContext) QName() antlr.TerminalNode {
	return s.GetToken(XPath31ParserQName, 0)
}

func (s *EqnameContext) URIQualifiedName() antlr.TerminalNode {
	return s.GetToken(XPath31ParserURIQualifiedName, 0)
}

func (s *EqnameContext) KW_ANCESTOR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ANCESTOR, 0)
}

func (s *EqnameContext) KW_ANCESTOR_OR_SELF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ANCESTOR_OR_SELF, 0)
}

func (s *EqnameContext) KW_AND() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AND, 0)
}

func (s *EqnameContext) KW_ARRAY() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ARRAY, 0)
}

func (s *EqnameContext) KW_AS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_AS, 0)
}

func (s *EqnameContext) KW_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ATTRIBUTE, 0)
}

func (s *EqnameContext) KW_CAST() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_CAST, 0)
}

func (s *EqnameContext) KW_CASTABLE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_CASTABLE, 0)
}

func (s *EqnameContext) KW_CHILD() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_CHILD, 0)
}

func (s *EqnameContext) KW_COMMENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_COMMENT, 0)
}

func (s *EqnameContext) KW_DESCENDANT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DESCENDANT, 0)
}

func (s *EqnameContext) KW_DESCENDANT_OR_SELF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DESCENDANT_OR_SELF, 0)
}

func (s *EqnameContext) KW_DIV() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DIV, 0)
}

func (s *EqnameContext) KW_DOCUMENT_NODE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_DOCUMENT_NODE, 0)
}

func (s *EqnameContext) KW_ELEMENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ELEMENT, 0)
}

func (s *EqnameContext) KW_ELSE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ELSE, 0)
}

func (s *EqnameContext) KW_EMPTY_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EMPTY_SEQUENCE, 0)
}

func (s *EqnameContext) KW_EQ() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EQ, 0)
}

func (s *EqnameContext) KW_EVERY() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EVERY, 0)
}

func (s *EqnameContext) KW_EXCEPT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_EXCEPT, 0)
}

func (s *EqnameContext) KW_FOLLOWING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FOLLOWING, 0)
}

func (s *EqnameContext) KW_FOLLOWING_SIBLING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FOLLOWING_SIBLING, 0)
}

func (s *EqnameContext) KW_FOR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FOR, 0)
}

func (s *EqnameContext) KW_FUNCTION() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_FUNCTION, 0)
}

func (s *EqnameContext) KW_GE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_GE, 0)
}

func (s *EqnameContext) KW_GT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_GT, 0)
}

func (s *EqnameContext) KW_IDIV() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IDIV, 0)
}

func (s *EqnameContext) KW_IF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IF, 0)
}

func (s *EqnameContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IN, 0)
}

func (s *EqnameContext) KW_INSTANCE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_INSTANCE, 0)
}

func (s *EqnameContext) KW_INTERSECT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_INTERSECT, 0)
}

func (s *EqnameContext) KW_IS() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_IS, 0)
}

func (s *EqnameContext) KW_ITEM() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_ITEM, 0)
}

func (s *EqnameContext) KW_LE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_LE, 0)
}

func (s *EqnameContext) KW_LET() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_LET, 0)
}

func (s *EqnameContext) KW_LT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_LT, 0)
}

func (s *EqnameContext) KW_MAP() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_MAP, 0)
}

func (s *EqnameContext) KW_MOD() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_MOD, 0)
}

func (s *EqnameContext) KW_NAMESPACE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NAMESPACE, 0)
}

func (s *EqnameContext) KW_NAMESPACE_NODE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NAMESPACE_NODE, 0)
}

func (s *EqnameContext) KW_NE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NE, 0)
}

func (s *EqnameContext) KW_NODE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_NODE, 0)
}

func (s *EqnameContext) KW_OF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_OF, 0)
}

func (s *EqnameContext) KW_OR() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_OR, 0)
}

func (s *EqnameContext) KW_PARENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PARENT, 0)
}

func (s *EqnameContext) KW_PRECEDING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PRECEDING, 0)
}

func (s *EqnameContext) KW_PRECEDING_SIBLING() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PRECEDING_SIBLING, 0)
}

func (s *EqnameContext) KW_PROCESSING_INSTRUCTION() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_PROCESSING_INSTRUCTION, 0)
}

func (s *EqnameContext) KW_RETURN() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_RETURN, 0)
}

func (s *EqnameContext) KW_SATISFIES() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SATISFIES, 0)
}

func (s *EqnameContext) KW_SCHEMA_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SCHEMA_ATTRIBUTE, 0)
}

func (s *EqnameContext) KW_SCHEMA_ELEMENT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SCHEMA_ELEMENT, 0)
}

func (s *EqnameContext) KW_SELF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SELF, 0)
}

func (s *EqnameContext) KW_SOME() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_SOME, 0)
}

func (s *EqnameContext) KW_TEXT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_TEXT, 0)
}

func (s *EqnameContext) KW_THEN() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_THEN, 0)
}

func (s *EqnameContext) KW_TREAT() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_TREAT, 0)
}

func (s *EqnameContext) KW_UNION() antlr.TerminalNode {
	return s.GetToken(XPath31ParserKW_UNION, 0)
}

func (s *EqnameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqnameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *EqnameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterEqname(s)
	}
}

func (s *EqnameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitEqname(s)
	}
}




func (p *XPath31Parser) Eqname() (localctx IEqnameContext) {
	localctx = NewEqnameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, XPath31ParserRULE_eqname)
	var _la int


	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		_la = p.GetTokenStream().LA(1)

		if !(((((_la - 36)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 36))) & ((1 << (XPath31ParserKW_ANCESTOR - 36)) | (1 << (XPath31ParserKW_ANCESTOR_OR_SELF - 36)) | (1 << (XPath31ParserKW_AND - 36)) | (1 << (XPath31ParserKW_ARRAY - 36)) | (1 << (XPath31ParserKW_AS - 36)) | (1 << (XPath31ParserKW_ATTRIBUTE - 36)) | (1 << (XPath31ParserKW_CAST - 36)) | (1 << (XPath31ParserKW_CASTABLE - 36)) | (1 << (XPath31ParserKW_CHILD - 36)) | (1 << (XPath31ParserKW_COMMENT - 36)) | (1 << (XPath31ParserKW_DESCENDANT - 36)) | (1 << (XPath31ParserKW_DESCENDANT_OR_SELF - 36)) | (1 << (XPath31ParserKW_DIV - 36)) | (1 << (XPath31ParserKW_DOCUMENT_NODE - 36)) | (1 << (XPath31ParserKW_ELEMENT - 36)) | (1 << (XPath31ParserKW_ELSE - 36)) | (1 << (XPath31ParserKW_EMPTY_SEQUENCE - 36)) | (1 << (XPath31ParserKW_EQ - 36)) | (1 << (XPath31ParserKW_EVERY - 36)) | (1 << (XPath31ParserKW_EXCEPT - 36)) | (1 << (XPath31ParserKW_FOLLOWING - 36)) | (1 << (XPath31ParserKW_FOLLOWING_SIBLING - 36)) | (1 << (XPath31ParserKW_FOR - 36)) | (1 << (XPath31ParserKW_FUNCTION - 36)) | (1 << (XPath31ParserKW_GE - 36)) | (1 << (XPath31ParserKW_GT - 36)) | (1 << (XPath31ParserKW_IDIV - 36)) | (1 << (XPath31ParserKW_IF - 36)) | (1 << (XPath31ParserKW_IN - 36)) | (1 << (XPath31ParserKW_INSTANCE - 36)) | (1 << (XPath31ParserKW_INTERSECT - 36)) | (1 << (XPath31ParserKW_IS - 36)))) != 0) || ((((_la - 68)) & -(0x1f+1)) == 0 && ((1 << uint((_la - 68))) & ((1 << (XPath31ParserKW_ITEM - 68)) | (1 << (XPath31ParserKW_LE - 68)) | (1 << (XPath31ParserKW_LET - 68)) | (1 << (XPath31ParserKW_LT - 68)) | (1 << (XPath31ParserKW_MAP - 68)) | (1 << (XPath31ParserKW_MOD - 68)) | (1 << (XPath31ParserKW_NAMESPACE - 68)) | (1 << (XPath31ParserKW_NAMESPACE_NODE - 68)) | (1 << (XPath31ParserKW_NE - 68)) | (1 << (XPath31ParserKW_NODE - 68)) | (1 << (XPath31ParserKW_OF - 68)) | (1 << (XPath31ParserKW_OR - 68)) | (1 << (XPath31ParserKW_PARENT - 68)) | (1 << (XPath31ParserKW_PRECEDING - 68)) | (1 << (XPath31ParserKW_PRECEDING_SIBLING - 68)) | (1 << (XPath31ParserKW_PROCESSING_INSTRUCTION - 68)) | (1 << (XPath31ParserKW_RETURN - 68)) | (1 << (XPath31ParserKW_SATISFIES - 68)) | (1 << (XPath31ParserKW_SCHEMA_ATTRIBUTE - 68)) | (1 << (XPath31ParserKW_SCHEMA_ELEMENT - 68)) | (1 << (XPath31ParserKW_SELF - 68)) | (1 << (XPath31ParserKW_SOME - 68)) | (1 << (XPath31ParserKW_TEXT - 68)) | (1 << (XPath31ParserKW_THEN - 68)) | (1 << (XPath31ParserKW_TREAT - 68)) | (1 << (XPath31ParserKW_UNION - 68)) | (1 << (XPath31ParserURIQualifiedName - 68)))) != 0) || _la == XPath31ParserQName) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



	return localctx
}


// IAuxilaryContext is an interface to support dynamic dispatch.
type IAuxilaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAuxilaryContext differentiates from other interfaces.
	IsAuxilaryContext()
}

type AuxilaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuxilaryContext() *AuxilaryContext {
	var p = new(AuxilaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = XPath31ParserRULE_auxilary
	return p
}

func (*AuxilaryContext) IsAuxilaryContext() {}

func NewAuxilaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuxilaryContext {
	var p = new(AuxilaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = XPath31ParserRULE_auxilary

	return p
}

func (s *AuxilaryContext) GetParser() antlr.Parser { return s.parser }

func (s *AuxilaryContext) EOF() antlr.TerminalNode {
	return s.GetToken(XPath31ParserEOF, 0)
}

func (s *AuxilaryContext) AllExpr() []IExprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExprContext)(nil)).Elem())
	var tst = make([]IExprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExprContext)
		}
	}

	return tst
}

func (s *AuxilaryContext) Expr(i int) IExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AuxilaryContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(XPath31ParserSEMI)
}

func (s *AuxilaryContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(XPath31ParserSEMI, i)
}

func (s *AuxilaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuxilaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AuxilaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.EnterAuxilary(s)
	}
}

func (s *AuxilaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(XPath31Listener); ok {
		listenerT.ExitAuxilary(s)
	}
}




func (p *XPath31Parser) Auxilary() (localctx IAuxilaryContext) {
	localctx = NewAuxilaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, XPath31ParserRULE_auxilary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
				{
					p.SetState(892)
					p.Expr()
				}
				{
					p.SetState(893)
					p.Match(XPath31ParserSEMI)
				}




		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
	}
	{
		p.SetState(899)
		p.Match(XPath31ParserEOF)
	}



	return localctx
}


func (p *XPath31Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 62:
			var t *FunctioncallContext = nil
			if localctx != nil { t = localctx.(*FunctioncallContext) }
			return p.Functioncall_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *XPath31Parser) Functioncall_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return  !(p.GetInputStream().LA(1)==XPath31ParserKW_ARRAY ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_ATTRIBUTE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_COMMENT ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_DOCUMENT_NODE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_ELEMENT ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_EMPTY_SEQUENCE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_FUNCTION ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_IF ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_ITEM ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_MAP ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_NAMESPACE_NODE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_NODE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_PROCESSING_INSTRUCTION ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_SCHEMA_ATTRIBUTE ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_SCHEMA_ELEMENT ||
	                          p.GetInputStream().LA(1)==XPath31ParserKW_TEXT) 

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

